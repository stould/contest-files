/*******Guia de Referencia - UNITAU **********//

Numbero de Divisores de um numero: p1^x1 * p2^x2 * ... pn^xn = for i 1..n ans *= (xi + 1);

//**********************************************
//Solver for mathematical expressions
void doOp(stack<double> &num, stack<char> &op){
        double A = num.top(); num.pop();
        double B = num.top(); num.pop();
        char oper = op.top(); op.pop();
        double ans;
        if(oper == '+'){
                ans = A+B;
        }else if(oper == '-'){
                ans = B-A;
        }else if(oper == '*'){
                ans = A*B;
        }else{
                if(A != 0){
                        ans = B/A;
                }else{
                        //division by 0
                        ans = -1;
                }
        }
        num.push(ans);
}
 
double parse(string s){
    stack<char> op;
    stack<double> num;
    map<char,int> priority;
    //setting the priorities, greater values with higher priority
    priority['+'] = 0;
    priority['-'] = 0;
    priority['*'] = 1;
    priority['/'] = 1;
    for(int i = 0; i < s.size(); i++){
        if(s[i] == ')'){
            while(!op.empty() && op.top() != '('){
                doOp(num,op);
            }
            op.pop();
        }else if(s[i] == '('){
                        op.push('(');
        }else if(!(s[i] >= '0' && s[i] <= '9')){
            while(!op.empty() && priority[s[i]] <= priority[op.top()] && op.top() != '('){
                doOp(num,op);
            }
            op.push(s[i]);
        }else{
            double ans = 0;
            while(i < s.size() && s[i] >= '0' && s[i] <= '9'){
                ans = ans * 10 + (s[i] - '0');
                i++;
            }
            i--;
            num.push(ans);
        }
    }
    while(op.size()){
        doOp(num,op);
    }
    return num.top();
}
//**********************************************
//Fast IO Read
inline void rd(int &x) {
    register int c = getchar_unlocked();	
    x = 0;
    int neg = 0;

    for (; ((c<48 || c>57) && c != '-'); c = getchar_unlocked());

    if (c=='-') {
        neg = 1;
        c = getchar_unlocked();
    }

    for ( ; c>47 && c<58 ; c = getchar_unlocked()) {
        x = (x<<1) + (x<<3) + c - 48;
    }

    if (neg) {
        x = -x;
    }
}
//**********************************************
//Java next_permutation
boolean next_permutation(int[] p) {
	for (int a = p.length - 2; a >= 0; --a)
		if (p[a] < p[a + 1])
			for (int b = p.length - 1; --b)
				if (p[b] > p[a]) {
					int t = p[a];
					p[a] = p[b];
					p[b] = t;
					for (++a, b = p.length - 1; a < b; ++a, --b) {
						t = p[a];
						p[a] = p[b];
						p[b] = t;
					}
					return true;
				}
	return false;
}
//**********************************************
//QuickSort O(N log N) worst case O(n^2)
int n, a[MAXN];

void quicksort(int lo, int hi) {
    int i=lo, j=hi, h;
	
    int x=a[(lo+hi)/2];

    do {
        while (a[i]<x) i++;
        while (a[j]>x) j--;
        if (i<=j) {
            swap(a[i], a[j]);
            i++;
            j--;
        }
    } while (i<=j);

    if (lo<j) quicksort(lo, j);
    if (i<hi) quicksort(i, hi);
}
//**********************************************
//Merge-Sort O(N log N)
vector<int> merge(vector<int>& b, vector<int>& c) {
	vector<int> a;

	while(!b.empty() && !c.empty()) {
		if(*b.begin() < *c.begin()) {
			a.push_back(*b.begin());
			b.erase(b.begin());
		} else if(*b.begin() > *c.begin()) {
			a.push_back(*c.begin());
			c.erase(c.begin());
		} else {
			a.pb(*b.begin());
			a.pb(*c.begin());
			b.erase(b.begin());
			c.erase(c.begin());
		}
	}
	while(!b.empty()) { a.pb(*b.begin()); b.erase(b.begin()); }
	while(!c.empty()) { a.pb(*c.begin()); c.erase(c.begin()); }
	return a;
}

vector<int> mergeSort(vector<int>& a) {
	if(sz(a) <= 1) {
		return a;
	}
	vector<int> b;
	vector<int> c;

	for(int i = 0; i < sz(a) / 2; i++) {
		b.pb(a[i]);
	}
	for(int i = sz(a) / 2; i < sz(a); i++) {
		c.pb(a[i]);
	}
	vector<int> sb = mergeSort(b);
	vector<int> sc = mergeSort(c);
	return merge(sb, sc);
}
//**********************************************
//Heapsort O(N log N)
int n, a[MAXN];

void downheap(int v) {
    int w = 2*v+1;
    while (w < n) {
        if(w + 1 < n) {
            if (a[w+1]>a[w]) w++;
        }
        if(a[v] >= a[w]) return;
        swap(a[v], a[w]);
        v = w;
        w = 2*v+1;
    }
}

void buildheap() {
    for (int v = n/2-1; v >= 0; v--) {
        downheap(v);
    }
}

void heapsort() {
    buildheap();
    while (n > 1) {
        n--;
        swap(a[0], a[n]);
        downheap(0);
    }
}

//**********************************************
//Merge Sort counting inversions (it's better to use Fenwick Tree to count inversions)
int merge(int arr[], int temp[], int left, int mid, int right);
 
int _mergeSort(int arr[], int temp[], int left, int right) {
	int mid, inv_count = 0;
	if (right > left) {
		mid = (right + left)/2;
		inv_count = _mergeSort(arr, temp, left, mid);
		inv_count += _mergeSort(arr, temp, mid+1, right);
		inv_count += merge(arr, temp, left, mid+1, right);
	}
	return inv_count;
}

int mergeSort(int arr[], int array_size) {
	int *temp = (int*) malloc(sizeof(int)*array_size);
	return _mergeSort(arr, temp, 0, array_size - 1);
}
 
int merge(int arr[], int temp[], int left, int mid, int right) {
	int i, j, k;
	int inv_count = 0;
 
	i = left;
	j = mid;
	k = left;
	while ((i <= mid - 1) && (j <= right)) {
		if (arr[i] <= arr[j]) {
			temp[k++] = arr[i++];
		} else {
			temp[k++] = arr[j++];
			inv_count = inv_count + (mid - i);
		}
	}
	
	while (i <= mid - 1) {
		temp[k++] = arr[i++];
	}
	
	while (j <= right) {
		temp[k++] = arr[j++];
	}

	for (i = left; i <= right; i++) {
		arr[i] = temp[i];
	}
	
	return inv_count;
}
//**********************************************
//Median in O(1)
int median_retrieve(void) {
	if (minHeap.empty() && maxHeap.empty()) return 0;
	
	if (minHeap.size() == maxHeap.size()) {
		return min(minHeap.top(), maxHeap.top());
	} else {
		if (minHeap.size() > maxHeap.size()) {
			return minHeap.top();
		} else {
			return maxHeap.top();
		}
	}
}

void median_insert(int x) {
	if (x > median_retrieve()) {
		minHeap.push(x);
	} else {
		maxHeap.push(x);
	}
	
	while (abs((int) (minHeap.size() - maxHeap.size())) > 1) {
		if (minHeap.size() > maxHeap.size()) {
			int tmp = minHeap.top();
			minHeap.pop();
			maxHeap.push(tmp);
		} else {
			int tmp = maxHeap.top();
			maxHeap.pop();
			minHeap.push(tmp);
		}
	}
}
//**********************************************
//Kadade 2D simplificaco
int best = 0;
for(int i = 1; i <= n; i++){
	for(int j = i; j <= n; j++){
		int tmp = 0;
		for(int k = 1; k <= n; k++){
			tmp += (freq[j][k] - freq[i-1][k]);
			best = max(tmp, best);
			if(tmp < 0){
				tmp = 0;
			}
		}
	}
 }
//////////////////////////////////////////////////////////
//Kadane 2D
for (int i = 1; i <= N; i++) {
	for (int j = 1; j <= N; j++) {
		cin >> M[i][j];
	}
	for (int j = 1; j <= N; j++) {
		dp[i][j] = dp[i][j - 1] + M[i][j];
	}
 }

int ans = -INT_MAX / 3;
for (int i = 1; i <= N; i++) {
	for (int j = i; j <= N; j++) {
		int sum = 0;
		for (int k = 1; k <= N; k++) {
			sum += dp[k][j] - dp[k][i - 1];
			chmax(ans, sum);
			if (sum < 0) sum = 0;
		}
	}
 }
//**********************************************
//Binary Search O(log n)
void search(int x) {
	int low = 0, high = INF, mid;

	while(low < high) {
		mid = low + (high - low) / 2;
		if(satisfied) {
			//High bound
			low = mid + 1;
		} else {
			high = mid;
		}
	}
	return low;
}
//**********************************************
//Binary Search for Real Number O(log N)
void search(double x) {
	int low = 0, high = INF, mid;
	for(int i = 0; i <= 100; i++) {
		mid = low + (high - low) / 2;
		if(satisfied) {
			low = mid;
		} else {
			high = mid;
		}
	}
	return low;
}
//**********************************************
//Split empty spaces in string
void split(vector<string>& v, const string& s) {
    istringstream ss(s, istringstream::in);
    v.clear(); string t;
    while(ss >> t) {
        v.push_back(t);
    }
}
//**********************************************
//String minimal lexicografical rotaton in O(n)
string min_lex (string s){
	n = s.size();
	s = s + s;
	int mini = 0, p = 1, l = 0;
	while(p < n && mini + l + 1 < n)
		if(s[mini + l] == s[p + l])
			l++;
		else if(s[mini + l] < s[p + l]){
			p = p + l + 1;
			l = 0;
		}
		else if(s[mini + l] > s[p + l]){
			mini = max(mini + l + 1, p);
			p = mini + 1;
			l = 0;
		}
	s = s.substr(mini, n);
	return s;
}

//**********************************************
//Knuth-Morris-Pratt O(n)
vector<int> KMP(string S, string K) {
    vector<int> T(K.size() + 1, -1);
    vector<int> matches;

    if(K.size() == 0) {
        matches.push_back(0);
        return matches;
    }
    for(int i = 1; i <= K.size(); i++) {
        int pos = T[i - 1];
        while(pos != -1 && K[pos] != K[i - 1]) pos = T[pos];
        T[i] = pos + 1;
    }

    int sp = 0;
    int kp = 0;
    while(sp < S.size()) {
        while(kp != -1 && (kp == K.size() || K[kp] != S[sp])) kp = T[kp];
        kp++;
        sp++;
        if(kp == K.size()) matches.push_back(sp - K.size());
    }

    return matches;
}
//**********************************************
//Manacher Algorithm (Longest Palindromic Substring)
string preProcess(string s) {
  int n = s.length();
  if (n == 0) return "^$";
  string ret = "^";
  for (int i = 0; i < n; i++)
    ret += "#" + s.substr(i, 1);
 
  ret += "#$";
  return ret;
}
 
vector<int> manacher(string s) {
  string T = preProcess(s);
  int n = T.length();
  vector<int> P(n);

  int C = 0, R = 0;
  for (int i = 1; i < n-1; i++) {
	  int i_mirror = 2*C-i;
	  
	  P[i] = (R > i) ? min(R-i, P[i_mirror]) : 0;
	  
	  while (T[i + 1 + P[i]] == T[i - 1 - P[i]]) {
		  P[i]++;
	  }
 
	  if (i + P[i] > R) {
		  C = i;
		  R = i + P[i];
	  }
  }
  
  int maxLen = 0;
  int centerIndex = 0;
  for (int i = 1; i < n-1; i++) {
	  if (P[i] > maxLen) {
		  maxLen = P[i];
		  centerIndex = i;
	  }
  }
  //to return actual longets substring
  //  return s.substr((centerIndex - 1 - maxLen)/2, maxLen);
  // P[i] is the length of the largest palindrome centered at i
  return P;
}
//**********************************************
//Z-Function O(n) => Z[i] = biggest prefix of a substring starting from i which is as a prefix of s
vector<int> z_function (string s) {
	int n = (int) s.length();
	vector<int> z (n);
	for (int i=1, l=0, r=0; i<n; ++i) {
		if (i <= r) {
			z[i] = min (r-i+1, z[i-l]);
		}
		while (i+z[i] < n && s[z[i]] == s[i+z[i]]) {
			++z[i];
		}
		if (i+z[i]-1 > r) {
			l = i;
			r = i+z[i]-1;
		}
	}
	return z;
}
//**********************************************
//Suffix Array O(n log n) and LCP in O(n)
//Better Implementation

const int MAXN = 100005;

// Begins Suffix Arrays implementation
// O(n log n) - Manber and Myers algorithm

//Usage:
// Fill str with the characters of the string.
// Call SuffixSort(n), where n is the length of the string stored in str.
// That's it!

//Output:
// pos = The suffix array. Contains the n suffixes of str sorted in lexicographical order.
//       Each suffix is represented as a single integer (the position of str where it starts).
// rnk = The inverse of the suffix array. rnk[i] = the index of the suffix str[i..n)
//        in the pos array. (In other words, pos[i] = k <==> rnk[k] = i)
//        With this array, you can compare two suffixes in O(1): Suffix str[i..n) is smaller
//        than str[j..n) if and only if rnk[i] < rnk[j]

int str[MAXN]; //input
int rnk[MAXN], pos[MAXN]; //output
int cnt[MAXN], nxt[MAXN]; //internal
bool bh[MAXN], b2h[MAXN];

bool smaller_first_char(int a, int b){
    return str[a] < str[b];
}

void SuffixSort(int n){
 //sort suffixes according to their first character
    for (int i=0; i<n; ++i){
        pos[i] = i;
    }
    sort(pos, pos + n, smaller_first_char);
 //{pos contains the list of suffixes sorted by their first character}

    for (int i=0; i<n; ++i){
        bh[i] = i == 0 || str[pos[i]] != str[pos[i-1]];
        b2h[i] = false;
    }

    for (int h = 1; h < n; h <<= 1){
   //{bh[i] == false if the first h characters of pos[i-1] == the first h characters of pos[i]}
        int buckets = 0;
        for (int i=0, j; i < n; i = j){
            j = i + 1;
            while (j < n && !bh[j]) j++;
            nxt[i] = j;
            buckets++;
        }
        if (buckets == n) break; // We are done! Lucky bastards!
   //{suffixes are separted in buckets containing strings starting with the same h characters}

        for (int i = 0; i < n; i = nxt[i]){
            cnt[i] = 0;
            for (int j = i; j < nxt[i]; ++j){
                rnk[pos[j]] = i;
            }
        }

        cnt[rnk[n - h]]++;
        b2h[rnk[n - h]] = true;
        for (int i = 0; i < n; i = nxt[i]){
            for (int j = i; j < nxt[i]; ++j){
                int s = pos[j] - h;
                if (s >= 0){
                    int head = rnk[s];
                    rnk[s] = head + cnt[head]++;
                    b2h[rnk[s]] = true;
                }
            }
            for (int j = i; j < nxt[i]; ++j){
                int s = pos[j] - h;
                if (s >= 0 && b2h[rnk[s]]){
                    for (int k = rnk[s]+1; !bh[k] && b2h[k]; k++) b2h[k] = false;
                }
            }
        }
        for (int i=0; i<n; ++i){
            pos[rnk[i]] = i;
            bh[i] |= b2h[i];
        }
    }
    for (int i=0; i<n; ++i){
        rnk[pos[i]] = i;
    }
}
// End of suffix array algorithm


// Begin of the O(n) longest common prefix algorithm
int lcp[MAXN];
// lcp[i] = length of the longest common prefix of suffix pos[i] and suffix pos[i-1]
// lcp[0] = 0
void getLcp(int n){
    for (int i=0; i<n; ++i) rnk[pos[i]] = i;
    lcp[0] = 0;
    for (int i=0, h=0; i<n; ++i){
        if (rnk[i] > 0){
            int j = pos[rnk[i]-1];
            while (i + h < n && j + h < n && str[i+h] == str[j+h]) h++;
            lcp[rnk[i]] = h;
            if (h > 0) h--;
        }
    }
}
// End of the longest common prefix algorithm

int N = (int) S.size();
				
for (int i = 0; i < N; i++) {
	str[i] = S[i];
}

SuffixSort(N);
getLcp(N);

//**********************************************
//Suffix Array
//Easier implementation
#define max 100010

int delta, len, SA[max], iSA[max], val[max], tval[max];
char s[max];
bool cmp(const int& a, const int& b) {
    return val[a+delta] < val[b+delta];
}

void build_SA() {
    int i, j;
    for (i=0; i<len; i++) val[i] = s[i];
    for (i=0; i<len; i++) SA[i] = i;

    delta = 0;
    sort(SA, SA+len, cmp);

    for(delta = 1; ; delta *= 2) {
        bool found = false;
        for(i = 0; i < len; i++) {
            for(j = i + 1; j < len; j++) if(val[SA[i]] != val[SA[j]]) break;
            if (j > i+1) {
                found = true;
                sort(SA+i, SA+j, cmp);
            }
            i = j - 1;
        }

        if(!found) break;
        tval[SA[0]] = 0;
        for(i = 1; i < len; i++) {
            tval[SA[i]] = tval[SA[i-1]];
            if(val[SA[i]] == val[SA[i-1]] && val[SA[i]+delta] == val[SA[i-1]+delta]);
            else tval[SA[i]]++;
        }
        memcpy(val, tval, len * sizeof(int));
    }
}

build_SA();
for (int i = 0; i < len; i++) printf("%d\n", SA[i]);

//**********************************************
//Aho Corasick Algorithm

#define foreach(x, v) for (typeof (v).begin() x=(v).begin(); x !=(v).end(); ++x)
#define For(i, a, b) for (int i=(a); i<(b); ++i)
#define D(x) cout << #x " is " << x << endl
 
/////////////////////////////////////////////////////////////////////////////////////////
// Aho-Corasick's algorithm, as explained in http://dx.doi.org/10.1145/360825.360855 //
/////////////////////////////////////////////////////////////////////////////////////////
 
const int MAXS = 6 * 50 + 10; // Max number of states in the matching machine.
// Should be equal to the sum of the length of all keywords.
 
const int MAXC = 26; // Number of characters in the alphabet.
 
int out[MAXS]; // Output for each state, as a bitwise mask.
// Bit i in this mask is on if the keyword with index i appears when the
// machine enters this state.
 
// Used internally in the algorithm.
int f[MAXS]; // Failure function
int g[MAXS][MAXC]; // Goto function, or -1 if fail.
 
// Builds the string matching machine.
//
// words - Vector of keywords. The index of each keyword is important:
// "out[state] & (1 << i)" is > 0 if we just found word[i] in the text.
// lowestChar - The lowest char in the alphabet. Defaults to 'a'.
// highestChar - The highest char in the alphabet. Defaults to 'z'.
// "highestChar - lowestChar" must be <= MAXC, otherwise we will
// access the g matrix outside its bounds and things will go wrong.
//
// Returns the number of states that the new machine has.
// States are numbered 0 up to the return value - 1, inclusive.
int buildMatchingMachine(const vector<string> &words, char lowestChar = 'a', char highestChar = 'z') {
	memset(out, 0, sizeof out);
	memset(f, -1, sizeof f);
	memset(g, -1, sizeof g);
	int states = 1; // Initially, we just have the 0 state
	for (int i = 0; i < words.size(); ++i) {
		const string &keyword = words[i];
		int currentState = 0;
		for (int j = 0; j < keyword.size(); ++j) {
			int c = keyword[j] - lowestChar;
			if (g[currentState][c] == -1) { // Allocate a new node
				g[currentState][c] = states++;
			}
			currentState = g[currentState][c];
		}
		out[currentState] |= (1 << i); // There's a match of keywords[i] at node currentState.
	}
	// State 0 should have an outgoing edge for all characters.
	for (int c = 0; c < MAXC; ++c) {
		if (g[0][c] == -1) {
			g[0][c] = 0;
		}
	}
	
	// Now, let's build the failure function
	queue<int> q;
	for (int c = 0; c <= highestChar - lowestChar; ++c) { // Iterate over every possible input
		// All nodes s of depth 1 have f[s] = 0
		if (g[0][c] != -1 and g[0][c] != 0) {
			f[g[0][c]] = 0;
			q.push(g[0][c]);
		}
	}
	while (q.size()) {
		int state = q.front();
		q.pop();
		for (int c = 0; c <= highestChar - lowestChar; ++c) {
			if (g[state][c] != -1) {
				int failure = f[state];
				while (g[failure][c] == -1) {
					failure = f[failure];
				}
				failure = g[failure][c];
				f[g[state][c]] = failure;
				out[g[state][c]] |= out[failure]; // Merge out values
				q.push(g[state][c]);
			}
		}
	}
	
	return states;
}

// Finds the next state the machine will transition to.
//
// currentState - The current state of the machine. Must be between
// 0 and the number of states - 1, inclusive.
// nextInput - The next character that enters into the machine. Should be between lowestChar
// and highestChar, inclusive.
// lowestChar - Should be the same lowestChar that was passed to "buildMatchingMachine".
 
// Returns the next state the machine will transition to. This is an integer between
// 0 and the number of states - 1, inclusive.
int findNextState(int currentState, char nextInput, char lowestChar = 'a') {
	int answer = currentState;
	int c = nextInput - lowestChar;
	while (g[answer][c] == -1) answer = f[answer];
	return g[answer][c];
}


// How to use this algorithm:
//
// 1. Modify the MAXS and MAXC constants as appropriate.
// 2. Call buildMatchingMachine with the set of keywords to search for.
// 3. Start at state 0. Call findNextState to incrementally transition between states.
// 4. Check the out function to see if a keyword has been matched.
//
// Example:
//
// Assume keywords is a vector that contains {"he", "she", "hers", "his"} and text is a string
// that contains "ahishers".
//
// Consider this program:
//
// buildMatchingMachine(v, 'a', 'z');
// int currentState = 0;
// for (int i = 0; i < text.size(); ++i) {
// currentState = findNextState(currentState, text[i], 'a');
// if (out[currentState] == 0) continue; // Nothing new, let's move on to the next character.
// for (int j = 0; j < keywords.size(); ++j) {
// if (out[currentState] & (1 << j)) { // Matched keywords[j]
// cout << "Keyword " << keywords[j] << " appears from "
// << i - keywords[j].size() + 1 << " to " << i << endl;
// }
// }
// }
//
// The output of this program is:
//
// Keyword his appears from 1 to 3
// Keyword he appears from 4 to 5
// Keyword she appears from 3 to 5
// Keyword hers appears from 4 to 7
 
/////////////////////////////////////////////////////////////////////////////////////////
// End of Aho-Corasick's algorithm. //
/////////////////////////////////////////////////////////////////////////////////////////
 
int main(){
	vector<string> keywords;
	keywords.push_back("he");
	keywords.push_back("she");
	keywords.push_back("hers");
	keywords.push_back("his");
	string text = "ahishers";
	buildMatchingMachine(keywords, 'a', 'z');
	int currentState = 0;
	for (int i = 0; i < text.size(); ++i) {
		currentState = findNextState(currentState, text[i], 'a');
		if (out[currentState] == 0) continue; // Nothing new, let's move on to the next character.
		for (int j = 0; j < keywords.size(); ++j) {
			if (out[currentState] & (1 << j)) { // Matched keywords[j]
				cout << "Keyword " << keywords[j] << " appears from "
					 << i - keywords[j].size() + 1 << " to " << i << endl;
			}
		}
	}
	return 0;
}
/* ******************************* GRAPH ************************* */
//DFS
void dfs(int x) {
    vis[x] = 1;
    for(int i = 1; i <= n; i++) {
        if(vis[i] == 0 && matrix[x][i] == 1) dfs(i);
    }
}
//**********************************************
//BFS
void bfs(int x) {
	int dist[N], vis[N]; 
	memset(dist, 0, sizeof(dist)); 
	memset(vis, 0, sizeof(vis));
	
	queue<int> q;
	q.push(x);
	vis[x] = true;
	dist[x] = 0;

	while(!q.empty()) {
		int tmp = q.front(); q.pop();
		vis[tmp] = true;

		for(int i = 1; i <= N; i++) {
			if(!vis[i] && matrix[tmp][i]) {
				q.push(i);
				dist[i] = dist[tmp] + 1;
			}
		}
	}
}
//**********************************************
//Topological Sort (Recursive)
vector<int> order;

void dfs(int x) {
    used[x] = 1;
    for(int b = 0; b < g[x].size(); b++) {
        if(!used[g[x][b]]) dfs(g[x][b]);
    }
    order.push_back(x);
}

reverse(order.begin(), order.end());


//**********************************************
//Topological Sort (Iterative) 
for (int i = 0; i < M; i++) {
	scanf("%d%d", &a, &b);
	graph[a].push_back(b);
	deg[b] += 1;
}
 
priority_queue<int, vector<int>, greater<int> > pq;
 
for (int i = 0; i < N; i++) {
	if(deg[i] == 0) {
		pq.push(i);
	}
 }
int on = 0;
while (!pq.empty()) {
	int now = pq.top(); 
	pq.pop();
	order.push_back(now);
	for (int i = 0; i < (int) graph[now].size(); i++) {
		int next = graph[now][i]; 
		deg[next] -= 1;
		
		if(deg[next] == 0) {
			pq.push(next);
		}
	}
 }
//**********************************************
//Ordenação topologica com checagem de ciclos: [OTCC]
//Se a variavel has se tornar verdade, o grafo contem um ciclo.
void dfs(int x) {
    vis[x] = 1;
    for(int u = 0; u < n; u++) {
        if(vis[u] == 1 && graph[x][u] == 1) has = true;
        if(vis[u] == 0 && graph[x][u] == 1) {
            dfs(u);
        }
    }
    vis[x] = 2;
    order.push_back(x);
}

//**********************************************
//[CFC] - Stongly Connected Components
ga -> Regular Adjacency List
gb -> Transposed Adjacency List

void dfs1(int x) {
    used[x] = 1;
    for(int b = 0; b < g[x].size(); b++) {
        if(!used[g[x][b]]) dfs1(g[x][b]);
    }
	order.push_back(x);		
}

void dfs2(int x) {
    used[x] = 1;
	comoponent.insert(x);
    for(int b = 0; b < gr[x].size(); b++) {
        if(!used[gr[x][b]]) dfs2(gr[x][b]);
    }
}

//Ordenando Topologicamente
for (int i = 1; i <= n; i++) if(!used[i]) dfs1(i);

//Procura pelos componentes:
for(int i = 0; i < order.size(); i++) {
    int v = order[i];
	if(!used[v]) {
		dfs2(v);
        ans++;
        component.clear();
	}
}
//**********************************************
//Bellman Ford - O(v * e)
vector <pair<int, int> > edges;
int graph[MAXN][MAXN]; 
int dist[MAXN];

int N; 
bool bellman_ford(int s) {
	int M = edges.size();
	memset (dist, INF, sizeof(int)*n);
	dist[s] = 0;
	for (int k = 0; k < N-1; ++k) {
		for (int j = 0; j < M; ++j) {
			int u = edges[j].first;
			int v = edges[j].second;
			if (dist[u] < INF && dist[v] > dist[u] + graph[u][v])
				dist[v] = dist[u] + graph[u][v];
		}
	}
	//Negative Cycle
	for (int j = 0; j < m; ++j) {
		int u = edges[j].first, v = edges[j].second;
		if (dist[u] < INF && dist[v] > dist[u] + graph[u][v]) {
			return false;
		}
	}
	return true;
}
//********************************************
//Determinando se um grafo é bipartido ou não:
//Sendo 'gr' a matrix de adjacencia representando o Grafo.
bool dfs(int node, int c) {
    if(color[node] != 0) {
        if(color[node] == c) {
            return true;
        } else {
            return false;
        }
    }
    color[node] = c;
    for(int i = 1; i <= n; i++) 
		if(gr[node][i] == 1) {
			if(!dfs(i, -c)) {
				return false;
			}
        }
    }
    return true;
}
//1-based graph
dfs(1, 1);
//othewise
dfs(0, 1);

//******************************************
//Return all cycles in a graph without compound cycles.
//cycle_len[i] is the length of the cycle i belongs to (for weighted graphs)
bool inq[MAXN], vis[MAXN];

void dfs(int node, int parent, int len) {
	vis[node] = true;
	cle[node] = len;
	
	stk[stk_pointer++] = node;
	inq[node] = true;

	for (int i = 0; i < (int) graph[node].size(); i++) {
		int next = graph[node][i].first;
		int cost = graph[node][i].second;
		
		if (next == parent) continue;
		
		if (!vis[next]) {
			dfs(next, node, len + cost);
		} else {
			if (inq[next]) {
				int curr;
				int real_len = len + cost - cle[next];
				
				while (stk_pointer > 0) {
					curr = stk[--stk_pointer];
					inq[curr] = false;
					cycle_len[curr] = real_len;
					if (curr == next) break;				
				}
			}
		}
	}

	if (inq[node]) {
		while (stk_pointer > 0) {
			inq[stk[stk_pointer-1]] = false;
			if (stk[stk_pointer-1] == node) {
				stk_pointer--;
				break;
			}
			stk_pointer--;
		}
	}
}

stk_pointer = 0;
dfs(1, -1, 0);		

//******************************************
//Matrix Multiplication
//Can be used for various problems, but can number of paths in adjacency matrix is it's preferred use
vector<vector<int> > multiply(vector<vector<int> > a, vector<vector<int> > b) {
	vector<vector<int> > res(c, vector<int>(c));
	for(int i = 0; i < c; i++) {
		for(int j = 0; j < c; j++) {
			int sum = 0;
			for (int k = 0; k < c; k++) {
				sum |= a[i][k] & b[k][j];
			}
			res[i][j] = sum;
		}
	}
	return res;
}

vector<vector<int> > binPow(vector<vector<int> > a, int n) {
	if (n == 1) {
		return a;
	} else if ((n & 1) != 0) {
		return multiply(a, binPow(a, n - 1));
	} else {
		vector<vector<int> > b = binPow(a, n / 2);
		return multiply(b, b);
	}
}

//******************************************
//Kruskal Algorithm
struct edge {
    int from, to, cost;
    edge() {}
    edge(int from, int to, int cost): from(from), to(to), cost(cost) {};

    bool operator<(const edge& e) const {
		return cost < e.cost;
    }
};
//Sendo 'M' o numero de arestas, 'u' uma implementação do conjunto disjunto 'UnionFind' e 'ans' o menor custo
vector<edge> edges; //Populado com as arestas
int ans = 0;
for(i = 0; i < m; i++) {
	if(!u.find(edges[i].from, edges[i].to)) {
		u.unite(edges[i].from, edges[i].to);
		ans += edges[i].cost;
	}
}

//******************************************
//Prim Algorithm
int g[MAXN][MAXN], used[MAXN], min_e[MAXN], sel_e[MAXN];
min_e[0] = 0;
for (int i = 0; i < n; ++i) {
	int v = -1;
	for(int j = 0; j < n; ++j) {
		if (!used[j] && (v == -1 || min_e[j] < min_e[v])) {
			v = j;
		}
	}
	used[v] = true;
	if (sel_e[v] != -1) {
		ans += min_e[v];
	}
	for (int to = 0; to < n; ++to) {
		if (g[v][to] < min_e[to]) {
			min_e[to] = g[v][to];
			sel_e[to] = v;
		}
	}
}
//*********************************************
//LCA O(<Nlog(N)>, <log(N)>)
int N, Q, A, B;
vector<pair<int, int> > adj[MAXN];
int parent[MAXN], L[MAXN], vis[MAXN];
vector<int> level[MAXN];
int P[MAXN][20];
Int dist[MAXN];

void dfs(int pos, int par){
    if(parent[pos] == -1){
        parent[pos] = par;
		
        for(int i = adj[pos].size() - 1,to;i >= 0;--i){
            to = adj[pos][i].first;
            if(to != par) {
                dist[to] = dist[pos] + adj[pos][i].second;
                dfs(to,pos);
            }
        }
    }
}

int get_level(int u){
    if(L[u]!=-1) return L[u];
    else if(parent[u]==-1) return 0;
    return 1+get_level(parent[u]);
}

void init() {
	for(int i = 0;i<N;++i) {
		L[i] = get_level(i);
	}

	for(int i = 0;i < N;++i) {
		level[L[i]].push_back(i);
	}

	memset(P,-1,sizeof(P));
	
	for(int i = 0; i < N; ++i) {
		P[i][0] = parent[i];
	}
	
	for(int j = 1; (1<<j) < N; ++j) {
		for(int i = 0; i < N; ++i) {
			if(P[i][j-1]!=-1) {
				P[i][j] = P[P[i][j-1]][j-1];
			}
		}
	}
}

int LCA(int p, int q) {
    if(L[p] < L[q]) {
		swap(p,q);
	}

    int log = 1;
    while((1<<log)<=L[p]) ++log;
    --log;

    for(int i = log;i>=0;--i)
        if(L[p]-(1<<i)>=L[q])
            p = P[p][i];

    if (p==q) return p;

    for(int i = log;i>=0;--i){
        if(P[p][i]!=-1 && P[p][i]!=P[q][i]){
            p = P[p][i];
            q = P[q][i];
        }
    }

    return parent[p];
}

for (i = 0; i <= N; i++) {
	vis[i] = 0;
	L[i] = parent[i] = -1;
	dist[i] = 0LL;
	adj[i].clear();
 }
for (i = 1; i < N; i++) {
	scanf("%d%d", &t, &l);
	adj[i].push_back(make_pair(t, l));
	adj[t].push_back(make_pair(i, l));
 }

dfs(0, -2);
parent[0] = -1;
init();
//*********************************************
//LCA using segment tree
int H[MAXN], L[MAXN << 1], E[MAXN << 1], vis[MAXN], tree[MAXN * 8], path[MAXN << 1];
vector<vector<pair<int, int> > > g(MAXN);

void dfs(int x, int depth){
	vis[x] = 1;//visited
	if(H[x] == -1) H[x] = idx;//mark first time the i'th node is visited
	L[idx] = depth;//when you visit a node you should mark the the depth you have found it.
	E[idx++] = x;//the i'th recursion, global variable
	for(int i = 0; i < g[x].size(); i++){
		int next = g[x][i].first;
		if(!vis[next]){
			path[next] = x;
			dfs(next, depth+1);
			L[idx] = depth;
			E[idx++] = x;
		}
	}
}

//NlogN build the segtree and minimize the height of the I'th visited node
void build(int node, int l, int r){
	if(l > r) return;
	if(l == r){
		tree[node] = l;
	}else{
		int mid = (l+r) >> 1;
		build(node*2, l, mid);
		build(node*2+1, mid+1, r);
		int A = tree[node*2];
		int B = tree[node*2+1];
		if(L[A] <= L[B]){
			tree[node] = A;
		}else{
			tree[node] = B;
		}
	}
}

//Get the vertex with the minimum height, then it will be the LCA of A and B.
int rmq(int node, int l, int r, int ra, int rb){
	if(l > rb || r < ra){
		return -1;
	}else if(l >= ra && r <= rb){
		return tree[node];
	}else{
		int mid = (l+r) >> 1;
		int q1 = rmq(node*2, l, mid, ra, rb);
		int q2 = rmq(node*2+1, mid+1, r, ra, rb);
		if(q1 == -1){
			return q2;
		}else if(q2 == -1){
			return q1;
		}else{
			if(L[q1] <= L[q2]){
				return q1;
			}else{
				return q2;
			}
		}
	}
}

idx = 0;
for(int i = 0; i <= n; i++){
	g[i].clear();
	H[i] = -1;
	L[i] = E[i] = vis[i] = 0;
	path[i] = -1;
 }
dfs(0,0);
build(1, 0, 2*n-1);
for(int i = 0; i < k; i++){
	scanf("%d%d", &u, &v);
	u--;
	v--;
	int goFrom = H[u];
	int goTo = H[v];
	if(goFrom > goTo){
		swap(goFrom, goTo);
	}
	int lcaAB = E[rmq(1, 0, 2*n-1, goFrom, goTo)]; //is the LCA of A and B;
 }

//*********************************************
//2-sat (temp implementation)
map<string, int> mp;
string c1, c2;
int vis[MAXN], low[MAXN], num[MAXN], sat[MAXN],dfs_counter, scc_counter ,n, test = 1;
vector<vector<int> > graph(MAXN);
stack<int> st;

//Find strongly connected components
void tarjan(int u, int depth) {
	low[u] = num[u] = depth;
	st.push(u);
	vis[u] = 1;
	for(int i = 0; i < graph[u].size(); i++) {
		int v = graph[u][i];
		if(num[v] == -1){
			tarjan(v, depth+1);
		}
		if (vis[v]){
			low[u] = min(low[u], low[v]);
		}
	}
	if(low[u] == depth) {
		while(1) {
			int next = st.top();st.pop();
			sat[next] = scc_counter;
			vis[next] = 0;
			if(u == next) break;
		}
		++scc_counter;
	}
}

/*
  To use the 2-SAT property, it could be transformed in a boolean logic with AND or OR
  A | B, means !A -> B
  !A | B, means !!A -> B equals to A -> B
  A | !B means !A -> !B
  !A | !B means !!A -> !B equals to A -> !B
  
  "-> is an implicance to separate the usege of A AND B"
  
  2-sat property is YES if all the components have no disturbs, e.g.:
  If you find !A and A in the same "scc", you're talking that !A = true AND A = true, it is not right.
*/
int main(void){
	ios::sync_with_stdio(0);
	while(cin >> n){
		mp.clear();
		for(int i = 0; i < MAXN; i++){
			graph[i].clear();
			vis[i] = 0;
			num[i] = -1;
			sat[i] = -1;
			low[i] = 0;
		}
		cin.ignore();
		int index = 0;
		//Graph mount:
		for(int i = 0; i < n; i++){
			cin >> c1 >> c2;
			string tmpA, tmpB;
			bool A = 1, B = 1;
			if(c1[0] == '!'){
				tmpA = c1.substr(1);
				A = 0;
			}else{
				tmpA = c1;
			}
			if(c2[0] == '!'){
				tmpB = c2.substr(1);
				B = 0;
			}else{
				tmpB = c2;
			}
			if(mp.find(tmpA) == mp.end()){
				mp[tmpA] = index;
				index += 2;
			}
			if(mp.find(tmpB) == mp.end()){
				mp[tmpB] = index;
				index += 2;
			}
			int U = mp[tmpA] + !A, V = mp[tmpB] + !B;
			graph[U^1].push_back(V);
			graph[V^1].push_back(U);
		}
		dfs_counter = scc_counter = 0;
		for(int i = 0; i < index; i++){
			if(num[i] == -1){
				tarjan(i, 0);
			}
		}
		int win = 1;
		//Checking disturbs
		for(int i = 0; i < index && win; i += 2){
			if(sat[i^1] == sat[i]) win = 0;
		}
		printf("Instancia %d\n", test++);
		if(win){
			printf("sim\n");
		}else{
			printf("nao\n");
		}
		printf("\n");
	}
	return 0;
}
//*********************************************
//Dijkstra
struct MyLess {
    bool operator()(int x, int y) {
        return dist[x] > dist[y];
    }
};

int dijsktra(int source, int destiny) {
	for(int i = 0; i <= 110; i++) {
		dist[i] = INT_MAX;
	}
	priority_queue<int, vector<int>, MyLess> q;
	dist[source] = 0;
 	q.push(source);

	while(!q.empty()) {
		int tmp = q.top(); q.pop();
		for(int i = 0; i < graph[tmp].size(); i++) {
            int aux_dist = dist[tmp] + graph[tmp][i].second;
            int actual_dist = dist[graph[tmp][i].first];
            if(aux_dist < actual_dist) {
                dist[graph[tmp][i].first] = aux_dist;
                q.push(graph[tmp][i].first);
            }
        }
    }
	return dist[destiny];
}
//Reconstrução do Caminho
vector<int> path;
int start = destiny;

while(start != -1) {
	path.push_back(start);
	start = prev[start];
}
//*******************************************************
//Counting Bridges in Graph
int dfsct, bridges, num[MAXN], low[MAXN], parent[MAXN];
 
void bridge(int atual){
    num[atual] = low[atual] = dfsct++;
    for(int i = 0; i < graph[atual].size(); i++){
        int next = graph[atual][i];
        if(num[next] == -1){
            parent[next] = atual;
            bridge(next);
            if(low[next] > num[atual]){
                bridges++;
            }
            low[atual] = min(low[atual], low[next]);
        }else if(next != parent[atual]){
            low[atual] = min(low[atual], num[next]);
        }
    }
}
 
void countBridges(){
    dfsct = bridges = 0;
    for(int i = 0; i < n; i++){
        num[i] = -1;
        parent[i] = 0;
    }
    for(int i = 0; i < n; i++){
        if(num[i] == -1) bridge(i);
    }
}
//*******************************************************
//Achando Vertices de Articulação um Grafo
vector<int> graph[410];
set<int> ans;
set<int>::iterator it;

int dfs(int u){
    int less = vis[u] = times++;
    int filhos = 0;
    for(int i = 0; i< graph[u].size(); i++){
       if(vis[graph[u][i]]==0){
          filhos++;
          int m = dfs(graph[u][i]);
          less = min(less,m);
          if(vis[u] <= m && (u != 0 || filhos >= 2)){
              ans.insert(u);
          }
       }else{
          less = min(less, vis[graph[u][i]]);
       }
    }
    return less;
}
times = 1;
ans.clear();
dfs(0);
//*******************************************************
//Heavy Light Decomposition
vector<vector<pair<int,int> > > g(MAXN);
int cnt[MAXN], prev[MAXN], chainNode[MAXN], chainHead[MAXN], posInChain[MAXN], base[MAXN], level[MAXN], chainIdx, idxSegTree;
int H[MAXN], L[MAXN << 1], E[MAXN << 1], idx;
 
struct LCA{        
        int tree[MAXN * 8];
        LCA(int root, int n){
                build(1, 0, 2*n-1);
        }
 
        //NlogN build the segtree and minimize the height of the I'th visited node
        void build(int node, int l, int r){
                if(l > r) return;
                if(l == r){
                        tree[node] = l;
                }else{
                        int mid = (l+r) >> 1;
                        build(node*2, l, mid);
                        build(node*2+1, mid+1, r);
                        int A = tree[node*2];
                        int B = tree[node*2+1];
                        if(L[A] <= L[B]){
                                tree[node] = A;
                        }else{
                                tree[node] = B;
                        }
                }
        }
 
        //Get the vertex with the minimum height, then it will be the LCA of A and B.
        int rmq(int node, int l, int r, int ra, int rb){
                if(l > rb || r < ra){
                        return -1;
                }else if(l >= ra && r <= rb){
                        return tree[node];
                }else{
                        int mid = (l+r) >> 1;
                        int q1 = rmq(node*2, l, mid, ra, rb);
                        int q2 = rmq(node*2+1, mid+1, r, ra, rb);
                        if(q1 == -1){
                                return q2;
                        }else if(q2 == -1){
                                return q1;
                        }else{
                                if(L[q1] <= L[q2]){
                                        return q1;
                                }else{
                                        return q2;
                                }
                        }
                }
        }
 
        int getLCA(int u, int v, int n){
                int goFrom = H[u];
                int goTo = H[v];
                if(goFrom > goTo){
                        swap(goFrom, goTo);
                }
                return E[rmq(1, 0, 2*n-1, goFrom, goTo)]; //is the LCA of A and B;
         }
};
 
struct SegTree{
 
                int tree[MAXN*4];
 
                SegTree(){
                        memset(tree,0,sizeof(tree));
                }
       
 
        void build(int node, int l, int r){
                if(l > r) return;
                if(l == r){
                        tree[node] = l;
                }else{
                        int mid = (l+r) >> 1;
                        build(node*2, l, mid);
                        build(node*2+1, mid+1, r);
                        int A = tree[node*2];
                        int B = tree[node*2+1];
                        tree[node] = base[A] > base[B] ? A : B;
                }
        }
 
        int rmq(int node, int l, int r, int ra, int rb){
                if(l > rb || r < ra){
                        return -1;
                }else if(l >= ra && r <= rb){
                        return tree[node];
                }else{
                        int mid = (l+r) >> 1;
                        int q1 = rmq(node*2, l, mid, ra, rb);
                        int q2 = rmq(node*2+1, mid+1, r, ra, rb);
                        if(q1 == -1){
                                return q2;
                        }else if(q2 == -1){
                                return q1;
                        }else{
                                return base[q1] > base[q2] ? q1 : q2;
                        }
                }
        }
       
        void update(int node, int l, int r, int pos, int value) {
                if (l > r) return;     
                if (l == r) {
                        base[pos] = value;
                } else {
                    int m = (l + r) >> 1;
                    if (pos <= m) {
                        update(2 * node, l, m, pos, value);
                    } else {
                        update(2 * node + 1, m + 1, r, pos, value);
                    }
                    tree[node] = base[tree[2 * node]] > base[tree[2 * node + 1]] ? tree[2 * node] : tree[2 * node + 1];
                }
        }
};
 
//Decompose the tree into chains
void HLD(int node, int cost, int parent){
        if(chainHead[chainIdx] == -1){
                chainHead[chainIdx] = node;
        }
        chainNode[node] = chainIdx;
        posInChain[node] = idxSegTree;
        base[idxSegTree++] = cost;
        int nodeHeavy = -1, nextCost;
        //seeking the special child (the one with most childs on the subtrees)
        for(int i = 0; i < g[node].size(); i++){
                int next = g[node][i].first;
                if(next != parent && (nodeHeavy == -1 || cnt[next] > cnt[nodeHeavy])){
                        nodeHeavy = next;
                        nextCost = g[node][i].second;
                }
        }
        if(nodeHeavy > -1){
                //expanding the current chain
                HLD(nodeHeavy, nextCost, node);
        }
       
        for(int i = 0; i < g[node].size(); i++){
                int next = g[node][i].first;
                if(next != nodeHeavy && next != parent){
                        chainIdx++;
                        HLD(next, g[node][i].second, node);
                }
        }
 
}
 
void dfsCnt(int node, int parent, int depth = 0){
        if(H[node] == -1) H[node] = idx;//mark first time the i'th node is visited
        L[idx] = depth;//when you visit a node you should mark the the depth you have found it.
        E[idx++] = node;//the i'th recursion, global variable
                level[node] = depth;
        cnt[node] = 1;
        for(int i = 0; i < g[node].size(); i++){
                int next = g[node][i].first;
                if(next != parent){
                        prev[next] = node;
                        dfsCnt(next, node, depth + 1);
                        cnt[node] += cnt[next];
                        L[idx] = depth;
                        E[idx++] = node;
                }
        }      
}
 
int walkChain(int U, int V, SegTree &q, int n){
        if(U == V) return 0;
        int ans = 0;
        while(chainNode[U] != chainNode[V]){
                int Left = posInChain[chainHead[chainNode[U]]];
                int Right = posInChain[U];
                int val = base[q.rmq(1, 0, n-1, Left, Right)];
                if(val > ans) ans = val;
                U = prev[chainHead[chainNode[U]]];
        }
        if(U == V) return ans;
        int val = base[q.rmq(1, 0, n-1, posInChain[V]+1, posInChain[U])];
        if(val > ans) ans = val;
        return ans;
}
 
int getMax(int U, int V, LCA &ref, SegTree &q, int n){
        int lca = ref.getLCA(U, V, n),a=0,b=0;
        if(lca != U)
                a = walkChain(U, lca, q, n);
        if(lca != V)
                b = walkChain(V, lca, q, n);
        return max(a,b);
}
 
void update(int a, int b, int c, SegTree &q, int n){
        if(level[a] < level[b]){//update b
                q.update(1,0,n-1,posInChain[b], c);
        }else{//update a
                q.update(1,0,n-1,posInChain[a], c);
        }
}
void add(int a, int b, int c){
        g[a].push_back(make_pair(b,c));
        g[b].push_back(make_pair(a,c));
}
 
int n, t, from[MAXN], to[MAXN], cost[MAXN], A, B;
char TYPE[20];
 
int main(void){
        scanf("%d", &t);
        while(t--){
                scanf("%d", &n);
                chainIdx = idxSegTree = idx = 0;
                for(int i = 0; i <= n; i++){
                        cnt[i] = prev[i] = chainNode[i] = base[i] = level[i] = 0;
                        chainHead[i] = posInChain[i] = H[i] = -1;
                        g[i].clear();
                }
                memset(L,0,sizeof(L));
                memset(E,0,sizeof(E));
                for(int i = 0; i < n - 1; i++){
                        scanf("%d%d%d", &from[i], &to[i], &cost[i]);
                        from[i]--;
                        to[i]--;
                        add(from[i], to[i], cost[i]);
                }
                dfsCnt(0,-1);
                LCA lca(0,n);
                HLD(0,-1, -1);
                SegTree query;
                query.build(1,0,n-1);
                while(1){
                        scanf("%s", TYPE);
                        if(TYPE[0] == 'D') break;
                        scanf("%d%d", &A, &B);
                        A--;
                        if(TYPE[0] == 'Q'){    
                                B--;
                                printf("%d\n", getMax(A, B, lca, query, n));
                        }else if(TYPE[0] == 'C'){
                                update(from[A], to[A], B, query, n);
                        }
                }
        }
    return 0;
}
//*******************************************************
//Fluxo-Máximo - Edmonds-Karp O(N*M^2)
int max_flow(int source, int sink) {
    int residual[MAXN][MAXN]; memset(residual, 0, sizeof(residual));
    while(1) {
        int prev[MAXN]; memset(prev, -1, sizeof(prev));
        int actual[MAXN]; memset(actual, 0, sizeof(actual));
        prev[source] = source;
        actual[source] = INF;
        queue<int> q; q.push(source);
        while(!q.empty()) {
            int u = q.front(); q.pop();
            for(int i = 0; i < graph[u].size(); i++) {
                int v = graph[u][i];
                if(capacity[u][v] - residual[u][v] > 0 && prev[v] == -1) {
                    prev[v] = u;
                    actual[v] = min(actual[u], capacity[u][v] - residual[u][v]);
                    if(v != sink) {
                        q.push(v);
                    } else {
                        while(prev[v] != v) {
                            u = prev[v];
                            residual[u][v] += actual[sink];
                            residual[v][u] -= actual[sink];
                            v = u;
                        }
                        goto end;
                    }
                }
            }
        }
        end:;
        if(prev[sink] == -1) {
            int sum = 0;
            for(int i = 0; i < MAXN; i++) {
                sum += residual[source][i];
            }
            return sum;
        }
    }
}
memset(capacity, 0, sizeof(capacity));
int n, m, a, b, c;
scanf("%d%d", &n, &m); //Tamanho/Numero de Arestar
for(int i = 0; i < m; i++) {
	scanf("%d%d%d", &a, &b, &c); //DE-PARA-CUSTO
	graph[a].push_back(b); capacity[a][b] += c;
	graph[b].push_back(a); capacity[b][a] += c;
}
//*******************************************************
//Max Flow dinic O(V^2*E)
const int MAXN = 101010;
const int INF = 101011;

struct edge {
    int to,rev;
    Int cap;
    edge(int to, Int cap, int rev): to(to), cap(cap), rev(rev) {}
};

vector<edge> G[MAXN];
Int level[MAXN];
int iter[MAXN];

void init(int N) {
    for (int i = 0; i < N; i++) {
        G[i].clear();
    }
}

void add_edge(int from,int to,Int cap) {
    G[from].push_back(edge(to, cap, G[to].size()));
    G[to].push_back(edge(from, 0, G[from].size()-1));
}

void bfs(int s) {
    memset(level, -1, sizeof(level));
    queue<int> que;
    level[s] = 0;
    que.push(s);

    while(!que.empty()) {
        int v = que.front();
        que.pop();
        for (int i = 0; i < G[v].size(); i++) {
            edge& e = G[v][i];
            if(e.cap > 0 && level[e.to] < 0) {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

Int dfs(int v, int t, Int f) {
    if(v == t) return f;
    for(int& i = iter[v]; i < (int) G[v].size(); i++) {
        edge &e = G[v][i];
        if(e.cap > 0 && level[v] < level[e.to]) {
            Int d = dfs(e.to, t, min(f, e.cap));
            if (d > 0) {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

int max_flow(int s, int t) {
    Int flow = 0;
    for( ; ; ) {
        bfs(s);
        if (level[t] < 0) {
            return flow;
        }
        memset(iter, 0, sizeof(iter));
        int f;
        while ((f=dfs(s,t,INF*INF)) > 0) {
            flow += f;
        }
    }
}
//********************************************
//Min Cost Max Flow with negative edges
const int maxn = 2002;
const int NEED_FLOW = 1000000000;

typedef int int_e;

struct edge {
	int from, to;
	int cap;
	int_e cost;
	int flow;
};

vector<edge> edges;

void add_edge(int from, int to, int_e cost, int cap) {
	edge e = {from, to, cap, cost, 0};
	edges.push_back(e);
	edge e2 = {to, from, 0, -cost, 0};
	edges.push_back(e2);
}

int_e mincost(int n, int s, int t) {
	int_e cost = 0;
	int flow = 0;
	while(flow < NEED_FLOW) {
		vector<int> p(n, -1);
		vector<int_e> d(n);
		d[s] = 0;
		p[s] = s;
		bool changed = true;
		while(changed) {
			changed = false;
			for(size_t i = 0; i < edges.size(); ++i) {
				edge& e = edges[i];
				if(e.cap == e.flow || p[e.from] == -1)
					continue;
				if(p[e.to] == -1 || d[e.to] > d[e.from] + e.cost) {
					d[e.to] = d[e.from] + e.cost;
					p[e.to] = i;
					changed = true;
				}
			}
		}
		if(p[t] == -1)
			break;
		if(d[t] >= 0) { // only for mincost, not mincostmaxflow
			break;
		}
		int cur = t;
		int maxAdd = NEED_FLOW - flow;
		while(cur != s) {
			edge& e = edges[p[cur]];
			cur = e.from;
			maxAdd = min(maxAdd, e.cap - e.flow);
		}
		flow += maxAdd;
		cost += d[t] * maxAdd;
		cur = t;
		while(cur != s) {
			int id = p[cur];
			edges[id].flow += maxAdd;
			edges[id ^ 1].flow -= maxAdd;
			cur = edges[id].from;
		}
	}
	// cost and flow are final here
	return cost;
}
//********************************************
///------Maxflow min-cut (Cutting edges only and restore the cutted edges)------///
vector<vector<int> > g(MAXN);
int n,m,u,v,c;
int cost[MAXN][MAXN], res[MAXN][MAXN], vis[MAXN], path[MAXN];
set<int> Sc;
 
int maxmatching(int s, int t){
        //      standart maxflow Edmonds-karp or Dinic
}
 
//Special case, the back edge have equal weight
void edge(int u, int v, int c){
	g[u].push_back(v);
	g[v].push_back(u);
	cost[u][v] = c;
	cost[v][u] = c;
}

//dfs from source
void dfs(int u){
	vis[u] = 1;
	Sc.insert(u);
	for(int i = 0; i < g[u].size(); i++){
		if(!vis[g[u][i]] && cost[u][g[u][i]] - res[u][g[u][i]] > 0){
			dfs(g[u][i]);
		}
	}
}

/*
  -Run the standart maxflow
  -Run dfs/bfs from source to get the reacheable (cost[U][V] - res[U][V] > 0) vertex and store in set Sc
  -Check for every vertex in Sc, check if the neighbor is not in Sc and if (cost[U][V] - res[U][V] <= 0), case true, edge from U to V was cutted.
*/
int main(void){
	while(scanf("%d%d", &n, &m) && (n+m)){
		for(int i = 0; i <= n; i++){
			g[i].clear();
		}
		Sc.clear();
		memset(cost,0,sizeof(cost));
		memset(res,0,sizeof(res));
		for(int i = 0; i < m; i++){
			scanf("%d%d%d", &u,&v, &c);
			edge(u-1,v-1,c);
		}
		maxmatching(0,1);
		memset(vis,0,sizeof(vis));
		dfs(0);
		for(set<int>::iterator it = Sc.begin(); it != Sc.end(); it++){
			for(int j = 0; j < g[*it].size(); j++){
				int next = g[*it][j];
				if(Sc.find(next) == Sc.end()){
					if(cost[*it][next] - res[*it][next] <= 0){
						//edge is off
						printf("%d %d\n", 1+(*it), 1+next);
					}
				}
			}
		}
		printf("\n");
	}
}
//********************************************
///-----Maxflow min-cut, destroy vertex and cut edges - Graph modeling------/////
int n, m, u, v, c, cost[MAXN][MAXN], res[MAXN][MAXN], vis[MAXN], path[MAXN];
vector<vector<int> > g(MAXN);

int maxMatching(int S, int T){
    standart maxflow
		}

/*
  
 */

int main(void){
    while(scanf("%d%d", &n, &m) && (n+m)){
        for(int i = 0; i < 2*n+1; i++){
            g[i].clear();
        }
        memset(res,0,sizeof(res));
        memset(cost,0,sizeof(cost));
        for(int i = 0; i < n-2; i++){
            scanf("%d%d", &u, &c);
            u--;
            g[u].push_back(u+n);
            g[u+n].push_back(u);
            cost[u][u+n] = c;
        }
        g[0].push_back(n);//0 = S
        g[n].push_back(0);//2*n-1 = T
        g[n-1].push_back((n << 1) - 1);
        g[(n << 1) - 1].push_back(n-1);
        cost[0][n] = INF;
        cost[n-1][(n << 1) - 1] = INF;
        for(int i = 0; i < m; i++){
            scanf("%d%d%d", &u,&v,&c);
            u--;v--;
            g[u+n].push_back(v);
            g[v].push_back(u+n);
            g[v+n].push_back(u);
            g[u].push_back(v+n);
            cost[u+n][v] = c;
            cost[v+n][u] = c;
        }
        printf("%d\n", maxMatching(0, (n << 1) - 1));
    }
}
//********************************************
// Minimum Cost Max Flow (good implementation)
struct edge {
    int to;
    int cap;
    int cost;
    int rev;
};

int V;
vector <edge> g[50];
int h[50];
int dist[50];
int prevv[50];
int preve[50];

void add_edge(int from, int to, int cap, int cost) {
    g[from].push_back((edge){to, cap, cost, g[to].size()});
    g[to].push_back((edge){from, 0, -cost, g[from].size() - 1});
}

long long min_cost_flow(int s, int t, int f) {
    long long res = 0, i;

    for (i = 0; i < V; i++) h[i] = 0;

    while (f > 0) {
        int d = f;
        priority_queue <pair<int, int> > q;

        for (i = 0; i < V; i++) dist[i] = 1e9;

        dist[s] = 0;

        q.push(make_pair(0, s));

        while (!q.empty()) {
            int c = -q.top().first;
            int v = q.top().second;

            q.pop();

            if (dist[v] < c) continue;

            for (i = 0; i < g[v].size(); i++) {
                edge &e = g[v][i];

                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {
                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];
                    prevv[e.to] = v;
                    preve[e.to] = i;
                    q.push(make_pair(-dist[e.to], e.to));
                }
            }
        }

        if (dist[t] == 1e9) return 1e9;

        for (i = 0; i < V; i++) h[i] += dist[i];

        for (i = t; i != s; i = prevv[i]) d = min(d, g[prevv[i]][preve[i]].cap);

        f -= d;

        res += d * h[t];

        for (i = t; i != s; i = prevv[i]) {
            edge &e = g[prevv[i]][preve[i]];
            e.cap -= d;
            g[i][e.rev].cap += d;
        }
    }

    return res;
}


//Min Cost Max Flow (Alternative Implementation)
typedef int Flow;
typedef int Cost;
const Flow INF = 0x3f3f3f3f;
struct Edge {
    int src, dst;
    Cost cst;
    Flow cap;
    int rev;
};
bool operator<(const Edge a, const Edge b) {
    return a.cst > b.cst;
}

typedef vector<Edge> Edges;
typedef vector<Edges> Graph;

void add_edge(Graph&G, int u, int v, Flow c, Cost l) {
    G[u].push_back((Edge){ u, v, l, c, int(G[v].size()) });
    G[v].push_back((Edge){ v, u, -l, 0, int(G[u].size()-1) });
}

pair<Flow, Cost> flow(Graph&G, int s, int t, int K) {
    int n = G.size();
    Flow flow = 0;
    Cost cost = 0;
    for ( ; ; ) {
        priority_queue<Edge> Q;
        vector<int> prev(n, -1), prev_num(n, -1);
        vector<Cost> length(n, INF);
        Q.push((Edge){-1,s,0,0,0});
        prev[s]=s;
        for (;!Q.empty();) {
            Edge e=Q.top();
			Q.pop();
            int v = e.dst;
            for (int i=0; i<(int)G[v].size(); i++) {
                if (G[v][i].cap>0 && length[G[v][i].dst]>e.cst+G[v][i].cst) {
                    prev[G[v][i].dst]=v;
                    Q.push((Edge){v, G[v][i].dst, e.cst+G[v][i].cst,0,0});
                    prev_num[G[v][i].dst]=i;
                    length[G[v][i].dst]=e.cst+G[v][i].cst;
                }
            }
        }
        if (prev[t]<0) return make_pair(flow, cost);
		
        Flow mi=INF;
        Cost cst=0;
        for (int v=t; v!=s; v=prev[v]) {
            mi=min(mi, G[prev[v]][prev_num[v]].cap);
            cst+=G[prev[v]][prev_num[v]].cst;
        }

		K -= cst*mi;
        cost+=cst*mi;

        for (int v=t; v!=s; v=prev[v]) {
            Edge &e=G[prev[v]][prev_num[v]];
            e.cap-=mi;
            G[e.dst][e.rev].cap+=mi;
        }
        flow += mi;
    }

}
//*****************************************************
//Maximum Bipartite Matching (Prefereed implementation)
vector<int> graph[MAXN];

bool bpm(int u, bool seen[], int matchR[]) {
    for (int i = 0; i < (int) graph[u].size(); i++) {
		int v = graph[u][i];

        if (!seen[v]) {
            seen[v] = true; 
 
            if (matchR[v] < 0 || bpm(matchR[v], seen, matchR)) {
                matchR[v] = u;
                return true;
            }
        }
    }
    return false;
}
 
int maxBPM() {
    int matchR[MAXN];
 
    memset(matchR, -1, sizeof(matchR));
 
    int result = 0; 
    for (int u = 1; u <= C; u++) {
        bool seen[MAXN];
        memset(seen, 0, sizeof(seen));
 
        if (bpm(u, seen, matchR)) {
            result++;
		}
    }
    return result;
}
//*****************************************************
//Maximum Bipartite Matching
int n, k;
vector<vector<int> > g;
vector<int> mt;
vector<char> used;

bool try_kuhn(int v) {
	if (used[v])  return false;
	used[v] = true;
	for (size_t i=0; i<g[v].size(); ++i) {
		int to = g[v][i];
		if (mt[to] == -1 || try_kuhn(mt[to])) {
			mt[to] = v;
			return true;
		}
	}
	return false;
}
mt.assign (k, -1);
for (int v=0; v<n; ++v) {
	used.assign (n, false);
	try_kuhn (v);
}

for (int i=0; i<k; ++i) {
	//Print partitions
	if (mt[i] != -1) {
		printf ("%d %d\n", mt[i]+1, i+1);
	}
 }

//*******************************************
//Floyd-Warshall - O(n^3)
for(int k = 0; k < n; k++) {
	for(int i = 0; i < n; i++) {
		for(int j = 0; j < n; j++) {
			dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
		}
	}
}
//*******************************************
//Global Min-Cut Stoer-Wager O(N^3)
int graph[MAXN][MAXN] //Matrix de Adjacencia do grafo.

int minCut(int n) {
    bool a[n];
    int v[n];
    int w[n];
    for(int i = 0; i < n; i++) v[i] = i;
    int best = INF;
    while(n > 1) {
        int maxj = 1;
        a[v[0]] = true;
        for(int i = 1; i < n; ++i) {
            a[v[i]] = false;
            w[i] = graph[v[0]][v[i]];
            if(w[i] > w[maxj]) {
                maxj = i;
            }
        }
        int prev= 0 ,buf = n;
        while(--buf) {
            a[v[maxj]]=true;
            if(buf == 1) {
                best = min(best, w[maxj]);
                for(int k = 0; k < n; k++) {
                    graph[v[k]][v[prev]]= (graph[v[prev]][v[k]] += graph[v[maxj]][v[k]]);
                }
                v[maxj] = v[--n];
            }
            prev = maxj;
            maxj = -1;
            for(int j = 1; j < n; ++j) {
                if(!a[v[j]]) {
                    w[j] += graph[v[prev]][v[j]];
                    if(maxj < 0 || w[j] > w[maxj]) {
                        maxj=j;
                    }
                }
            }
        }
    }
    return best;
}
//*****************************Geometria*************************************//
///----Closes pair with divide and conquer----///
struct point{
    double x, y;
    point(double a, double b): x(a), y(b){}
    point(){};
};

bool compareX(point a, point b){
    return a.x < b.x;
}

bool compareY(point a, point b){
    return a.y < b.y;
}
 
double bruteForce(vector<point> &p){
    double ans = 40000.*40001.;
    for(int i = 0; i < p.size(); i++){
        for(int j = i + 1; j < p.size(); j++){
            double dst = hypot(p[j].x - p[i].x, p[j].y - p[i].y);
            if(dst < ans){
                ans = dst;
            }
        }
    }
    return ans;
}
 
double strip(vector<point> &p, double d){
    sort(p.begin(), p.end(), compareY);
    double ans = d;
    for(int i = 0; i < p.size(); i++){
        for(int j = i + 1; j < p.size() && (p[j].y - p[i].y) < d; j++){
            double dst = hypot(p[j].x - p[i].x, p[j].y - p[i].y);
            if(dst < ans){
                ans = dst;
            }
        }
    }
    return ans;
}
 
double X, Y;
int n;
double closest(vector<point> v){
    int n = v.size();
    if(n <= 3){
            return bruteForce(v);
    }
    vector<point> left;
    vector<point> right;
    int mid = n >> 1;
    for(int i = 0; i < mid; i++){
        left.push_back(v[i]);
    }
    for(int i = mid; i < n; i++){
        right.push_back(v[i]);
    }
 
    double lh = closest(left);
    double rh = closest(right);
    double d = min(lh,rh);
    vector<point> stripArray;
    for(int i = 0; i < n; i++){
        if(fabs(v[i].x - v[mid].x) < d){
            stripArray.push_back(v[i]);
        }
    }
    return min(d, strip(stripArray,d));
}
 
sort(pos.begin(), pos.begin()+n, compareX);
double ans = closest(pos);
//*********************************
//Distance between point - line
double dot(pair<int, int> &A, pair<int, int> &B, pair<int, int> &C) {
    return (double) (B.first - A.first) * (C.first - B.first) + (B.second - A.second) * (C.second - B.second);
}

double cross(pair<int, int> &A, pair<int, int> &B, pair<int, int> &C) {
    return (double) (B.first-A.first) * (C.second-A.second) - (B.second-A.second) * (C.first-A.first);
}

double _distance(pair<int, int> A, pair<int, int> B) {
    int d1 = A.first - B.first;
    int d2 = A.second - B.second;
    return sqrt(d1*d1+d2*d2);
}

double linePointDist(pair<int, int> A, pair<int, int> B, pair<int, int> C, bool isSegment) {
    double dist = cross(A,B,C) / _distance(A,B);
    if(isSegment) {
        int dot1 = dot(A,B,C);
        if(dot1 > 0)return _distance(B,C);
        int dot2 = dot(B,A,C);
        if(dot2 > 0)return _distance(A,C);
    }
    return abs(dist);
}
//*********************************
//Cordenadas integrais em um segmento, incluindo os pontos iniciais e finais:
//Segmento entre pontos (x1, y1) e (x2, y2) = gcd(abs(x1 - x2), abs(y1 - y2)) + 1

//*****************************
//Area de um Poligono Convexo
double area() {
	int N = 4;
	int[] x = { 2, -4, 5, 2 };
	int[] y = { 5, 3, 1, 5 };

	double ma = x[N - 1] * y[0], mb = x[0] * y[N - 1];

	for (int i = 0; i < N - 1; i++) {
		ma += (x[i] * y[i + 1]);
		mb += (x[i + 1] * y[i]);
	}

	double ans = Math.abs((ma - mb) * 0.5);
}
//*********************************
//Distancia em linha reta (straight line)
double euclideanDistance(int x1, x2, int y1, int y2){
	return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));
}
//***********************************
// distancia
double manhatanDistance(int x1, int x2, int y1, int y2){
	return abs(x1 - x2) + abs(y2 - y1);
}
//************************************
//area do circulo
double circleArea(double r){
	return (r * r) * acos(-1);
}
//**************************************
//raio do circulo
double raio(int circunferencia){
	return circunferencia / acos(-1) / 2;
}
//***************************************
//Convex Hull
struct point {
    int x, y;
    point(int x, int y): x(x), y(y){}
    point(){}
    bool operator <(const point &p) const {
        return x < p.x || (x == p.x && y < p.y);
    }
    bool operator==(const point &p) const {
        return x == p.x && y == p.y;
    }
};
ll cross(const point &O, const point &A, const point &B) {
    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);
}

vector<point> convex_hull(vector<point> &P) {
    int n = P.size(), k = 0;
    vector<point> H(2*n);

    sort(P.begin(), P.end());

    for (int i = 0; i < n; i++) {
        while (k >= 2 && cross(H[k-2], H[k-1], P[i]) <= /*change to < to remove equal points */ 0) k--;
        H[k++] = P[i];
    }
    for (int i = n-2, t = k+1; i >= 0; i--) {
        while (k >= t && cross(H[k-2], H[k-1], P[i]) <= /*change to < to remove equal points */ 0) k--;
        H[k++] = P[i];
    }
    H.resize(k);
    return H;
}
//***************************************
//Point structure
//Piece of code stracted from the hichhikin guide to programming
//start from any initial values.

const double PI = 2.0*acos(0.0);
const double EPS = 1e-9; //too small/big?????
struct PT {
	double x,y;
	double length() {
		return sqrt(x*x+y*y);
	}
	int normalize() {
		double l = length();
		if(fabs(l)<EPS) return -1;
		x/=l; y/=l;
		return 0;
	}
	PT operator-(PT a) {
		PT r;
		r.x=x-a.x; r.y=y-a.y;
		return r;
	}
	PT operator+(PT a){
		PT r;
		r.x=x+a.x; r.y=y+a.y;
		return r;
	}
	PT operator*(double sc) {
		PT r;
		r.x=x*sc; r.y=y*sc;
		return r;
	}
};
bool operator<(const PT& a,const PT& b) {
	if(fabs(a.x-b.x)<EPS) return a.y<b.y;
	return a.x<b.x;
}
double dist(PT& a, PT& b){
	return sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));
}
double dot(PT& a, PT& b) {
	return(a.x*b.x+a.y*b.y);
}
r.x=x*sc; r.y=y*sc;
// Areas
// ===============================================================
double trap(PT a, PT b) {
	return (0.5*(b.x - a.x)*(b.y + a.y));
}
double area(vector<PT> &vin) {
	// Area of a simple polygon, not neccessary convex
	int n = vin.size();
	double ret = 0.0;
	for(int i = 0; i < n; i++) {
		ret += trap(vin[i], vin[(i+1)%n]);
	}
	return fabs(ret);
}
double peri(vector<PT> &vin) {
	// Perimeter of a simple polygon, not neccessary convex
	int n = vin.size();
	double ret = 0.0;
	for(int i = 0; i < n; i++) {
		ret += dist(vin[i], vin[(i+1)%n]);
	}
	return ret;
}
double triarea(PT a, PT b, PT c) {
	//Triangle area
	return fabs(trap(a,b)+trap(b,c)+trap(c,a));
}
double height(PT a, PT b, PT c) {
	// height from a to the line bc
	double s3 = dist(c, b);
	double ar = triarea(a,b,c);
	return (2.0*ar/s3);
}
//***************************************
//Check wheter a polygon is convex
int sideSign(PT& p1,PT& p2,PT& p3) {
	// which side is p3 to the line p1->p2? returns: 1 left, 0 on, -1 right
	double sg = (p1.x-p3.x)*(p2.y-p3.y)-(p1.y - p3.y)*(p2.x-p3.x);
	if (fabs(sg)<EPS) return 0;
	if (sg>0) return 1;
	return -1;
}
int isConvex(vector<PT>& v) {
	// test whether a simple polygon is convex
	// return 0 if not convex, 1 if strictly convex,
	// 2 if convex but there are points unnecesary
	// this function does not work if the polycon is self intersecting
	// in that case, compute the convex hull of v, and see if both have the same area
	int i,j,k;
	int c1=0; int c2=0; int c0=0;
	int n=v.size();
	for(i = 0;i < n; i++) {
		j= (i+1)%n;
		k= (j+1)%n;
		int s = sideSign(v[i], v[j], v[k]);
		if (s == 0) c0++;
		if (s > 0) c1++;
		if (s < 0) c2++;
	}
	if(c1 && c2) return 0;
	if(c0) return 2;
	return 1;
}
// ====================================================
// Points and Lines
// ====================================================
int intersection( PT p1, PT p2, PT p3, PT p4, PT &r) {
	// two lines given by p1->p2, p3->p4 r is the intersection point
	// return -1 if two lines are parallel
	double d = (p4.y - p3.y)*(p2.x-p1.x) - (p4.x - p3.x)*(p2.y - p1.y);
	if( fabs( d ) < EPS ) return -1;
	// might need to do something special!!!
	double ua, ub;
	ua = (p4.x - p3.x)*(p1.y-p3.y) - (p4.y-p3.y)*(p1.x-p3.x);
	ua /= d;
	// ub = (p2.x - p1.x)*(p1.y-p3.y) - (p2.y-p1.y)*(p1.x-p3.x);
	//ub /= d;
	r = p1 + (p2-p1)*ua;
	return 0;
}

void closestpt( PT p1, PT p2, PT p3, PT &r) {
	// the closest point on the line p1->p2 to p3
	if (fabs( triarea( p1, p2, p3)) < EPS) {
		r = p3;
		return;
	}
	PT v = p2-p1;
	v.normalize();
	double pr; // inner product
	pr = (p3.y-p1.y)*v.y + (p3.x-p1.x)*v.x;
	r = p1+v*pr;
}
int hcenter( PT p1, PT p2, PT p3, PT& r) {
	// point generated by altitudes
	if (triarea( p1, p2, p3 ) < EPS) return -1;
	PT a1, a2;
	closestpt( p2, p3, p1, a1 );
	closestpt( p1, p3, p2, a2 );
	intersection( p1, a1, p2, a2, r );
	return 0;
}
int center( PT p1, PT p2, PT p3, PT& r) {
	// point generated by circumscribed circle
	if (triarea( p1, p2, p3 ) < EPS) return -1;
	PT a1, a2, b1, b2;
	a1 = (p2+p3)*0.5;
	a2 = (p1+p3)*0.5;
	b1.x = a1.x - (p3.y-p2.y);
	b1.y = a1.y + (p3.x-p2.x);
	b2.x = a2.x - (p3.y-p1.y);
	b2.y = a2.y + (p3.x-p1.x);
	intersection(a1, b1, a2, b2, r);
	return 0;
}

//***************************************
//Biblioteca de fracoes
struct fraction {
    int num, denom;
    fraction(int num, int denom): num(num), denom(denom){
    }
    fraction() { num = 0; denom = 0; }
    void reduce(fraction& f) {
        int l = gcd(f.num, f.denom);
        f.num = f.num/l;
        f.denom = f.denom/l;
    }
    fraction operator+(const fraction& f) {
        fraction ans;
        int l = lcm(denom, f.denom);
        ans.num = ((l / denom) * num) + ((l / f.denom) * f.num);
        ans.denom = l;
        reduce(ans);
        return ans;
    }
    fraction operator-(const fraction& f) {
        fraction ans;
        ans.num = num - f.num;
        ans.denom = denom - f.denom;
        reduce(ans);
        return ans;
    }
    fraction operator*(const fraction& f) {
        fraction ans;
        ans.num = num * f.num;
        ans.denom = denom * f.denom;
        reduce(ans);
        return ans;
    }
    fraction operator/(const fraction& f) {
        fraction ans;
        ans.num = num * f.denom;
        ans.denom = denom * f.num;
        reduce(ans);
        return ans;
    }
    bool operator!=(const fraction& f) {
        return num != f.num || denom != f.denom;
    }
    bool operator==(const fraction& f) {
        return num == f.num && denom == f.denom;
    }
    friend ostream &operator<<(ostream &out, fraction f) {
        out << f.num << "/" << f.denom << "\n";
        return out;
    }
    friend istream &operator>>(istream &in, fraction f) {
        in >> f.num >> f.denom;
        return in;
    }
};


//***************************************
//Polygon Area
int area = 0;
int N = lengthof(p);
//We will triangulate the polygon
//into triangles with points p[0],p[i],p[i+1]

for(int i = 1; i+1<N; i++){
    int x1 = p[i][0] - p[0][0];
    int y1 = p[i][1] - p[0][1];
    int x2 = p[i+1][0] - p[0][0];
    int y2 = p[i+1][1] - p[0][1];
    int cross = x1*y2 - x2*y1;
    area += cross;
}
return abs(cross/2.0);
//*******************************************************
//Checando se 2 segmentos se cruzam
A = y2-y1
B = x1-x2
C = A*x1+B*y1
A1x + B1y = C1
A2x + B2y = C2
double det = A1*B2 - A2*B1
if(det == 0){
	//Lines are parallel
}else{
	double x = (B2*C1 - B1*C2)/det
   double y = (A1*C2 - A2*C1)/det
}
/* ************************************ Dynamic Programming ***************************** */
//*******************************************************
//Binomial Coefficient
//C(N, K) = N!/(K!(N - K)!)
//Dynamic Programming
int bin[N][K];

bin[0][0] = 1;

for (int n = 1; n < MAXN; n++) {
    bin[n][0] = 1;
    bin[n][n] = 1;
	
    for (int k = 1; k < n; k++) {
		bin[n][k] = bin[n - 1][k] + bin[n - 1][k - 1];
		if (bin[n][k] >= MOD) {
			bin[n][k] -= MOD;
		}
    }
 }
//
Int nCr(Int n, Int k) {
	Int res = 1;
	
	if (k > (n >> 1LL)) {
		k = n-k;
	}
	for (Int i = 1; i <= k; i++, n--) {
		res = (res * n) / i;
	}
	
	return res;
}

//*******************************************************


//*******************************************************
//String distance
int dist(string& s1, string& s2) {
    int N1 = s1.size(), N2 = s2.size();

    for (int i = 0; i <= N1; i++) dp[i][0] = i;
    for (int i = 0; i <= N2; i++) dp[0][i] = i;

    for (int i = 1; i <= N1; i++) {
		for (int j = 1; j <= N2; j++) {
			if(s1[i-1] == s2[j-1]) {
				dp[i][j] = dp[i-1][j-1];
			} else {
				dp[i][j] = 1 + min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]);
			}
		}
	}
	return dp[N1][N2];
}
//*******************************************************
//Coin Change
int dp[1001];
int coins[] = {1, 5, 10, 25, 50};

dp[0] = 0;

for(int i = 1; i <= N; i++) {
	int min = 1000001;
    for(int j = 0; j < M; j++) {
		if(coins[j] <= i) {
			int m = dp[i - coins[j]] + 1;
            if(m < min) min = m;
        }
    }
    dp[i] = min;
}
//*******************************************************
//Counting ways to sum value 'x' using coins in set 'coins'
memo[0] = 1;

for(int i = 0; i < 5; i++) {
    int c = coins[i];
    for(int j = c; j <= x; j++) {
	memo[j] += memo[j - c];
    }
}
//*******************************************************
//Longest Increasing Subsequence - (LIS) O(n*log(n)) retrieving path
void find_lis() {
	topo = 1;
	quem[0] = a[0];
    pos[0] = 0;
	pai[0] = -1;

	for (int i = 1; i < n; i++){
        if (quem[topo-1] <= a[i]){
            quem[topo] = a[i]; pos[topo++] = i;
            pai[i] = pos[topo-2];
            continue;
        }
        int x = upper_bound (quem, quem+topo, a[i])-quem;
        quem[x] = a[i]; pos[x] = i;
        if (x == 0) pai[i] = -1;
        else pai[i] = pos[x-1];
	}
}

find_lis();
vector <int> ret;
printf("Max hits: %d\n", topo);

for (int i = pos[topo-1]; i != -1; i = pai[i]) ret.push_back(a[i]);
for (int i = ret.size()-1; i >=0; i--) printf("%d\n", ret[i]);


//*******************************************************
//Longest Increasing Subsequence - (LIS) O(Nlog(N))
void funcA(void) {
    int top = 0;

    stk[0] = INT_MIN;

    for (int i = 0; i < N; ++i) {
        if (v[i] > stk[top]) {
            stk[++top] = v[i];
        } else {
            int low = 0, high = top;
            while (low <= high) {
                int mid = (low + high) >> 1;
                if (v[i] > stk[mid]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
            stk[low] = v[i];
        }
        in[i] = top;
    }
}
//*******************************************************
//Longest Increasing Subsequence - (LIS) O(N^2)
int lis(int array[], int n) {
    int best[n], prev[n];

    for(int i = 0; i < n; i++) {
        best[i] = 1;
        prev[i] = i;
    }

    for(int i = 1; i < n; i++) {
        for(int j = 0; j < i; j++) {
            if(array[i] > array[j] && best[i] < best[j] + 1) {
                best[i] = best[j] + 1; prev[i] = j;
            }
        }
    }
    int ans = 0; for(int i = 0; i < n; i++) ans = max(ans, best[i]);
    return ans;
}
//*******************************************************
//Longest Commom Subsequence - (LCS) O(N^2)
int lcs(string a, string b) {
	int n = a.size(), m = b.size();
	int[][] dp = new dp[n+1][m+1];

	for(int i = 0; i <= max(n, m); i++) {
		dp[i][0] = dp[0][i] = 0;
	}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			if(a[i] == b[j]) {
				dp[i][j] = dp[i - 1][j - 1] + 1;
			} else {
				dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
			}
		}
	}
	return dp[n][m];
}
//*******************************************************
//Longest Commom Subsequence - (LCS) O(n^2) - O(n) in space
int m[2][1000]; // instead of [1000][1000]
for (i = M; i >= 0; i--) {
	int ii = i&1; 
	for (int j = N; j >= 0; j--) {
		if (i == M || j == N) {
			m[ii][j]=0; continue;
		}
		if (s1[i] == s2[j]) {
			m[ii][j] = 1 + m[1-ii][j+1];
		} else {
			m[ii][j] = max(m[ii][j+1], m[1-ii][j]);
		}
	}
 }
cout<<m[0][0];
//*******************************************************	
//Menor string que contem duas strings S1 e S2 como subsequencia

char S1[MAXS], S2[MAXS];
int dp[MAXS][MAXS];

memset(dp, 0, sizeof(dp));

for (i = 1; i <= N; i++) {
    for (j = 1; j <= M; j++) {
        if (S1[i - 1] == S2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
        } else {
           dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        }
    }
}

string track(int i, int j) {
    if (i == 0 && j == 0) {
        return "";
    } else if (i == 0 && j > 0) {
        return track(i, j - 1) + S2[j - 1];
    } else if (i > 0 && j == 0) {
        return track(i - 1, j) + S1[i - 1];
    } else {
        if (S1[i - 1] == S2[j - 1]) {
            return track(i - 1, j - 1) + S1[i - 1];
        } else {
            if (dp[i][j - 1] > dp[i - 1][j]) {
                return track(i, j - 1) + S2[j - 1];
            } else {
                return track(i - 1, j) + S1[i - 1];
            }
        }
    }
}
//*******************************************************
//Subset-Sum -> (G = O valor total sendo testado, N = numero de valores disponiveis no array 'values'
int values[n];
bool subsetSum(int n, int g) {
    for(j = 0; j <= g; j++) sub[j] = 0;
    sub[0] = 1;
    for(j = 0; j < n; j++) if(values[j] != g) {
        for(int k = g; k >= values[j]; k--) {
            sub[k] |= sub[k - values[j]];
        }
    }
    return sub[g];
}
//*******************************************************
//Checa por Palindromos
int T, N, dp[MAXN][MAXN];
char str[MAXN];

for (int i = 0; i < N; i++) {
    dp[i][i] = 1;
    if(i + 1 < N) dp[i][i + 1] = str[i] == str[i + 1];
}
for(int k = 2; k < N; k++) {
    for (int i = 0; i < N - k; i++) {
        dp[i][i + k] = dp[i + 1][i + k - 1] && str[i] == str[i + k];
    }
}
//Find string period
vector<int> prefix = KMP(S); //KMP Prefix function array
for (int i = 0; i < (int) prefix.size(); i++) {
	if (prefix[i] >= (int)  S.size() / 2) {
		period_len = i - prefix[i];		
	}
 }

//*******************************************************
//Domino perfect matching - recursive
int a, b, i, j, k, n, ok, teste = 1, mem[7][7];

void rec(int now, int deep) {
    if(deep == n) {
        ok = 1;
        return;
    }
    for(j = 0; j <= 6; j++) {
        int i = j;
        if(mem[now][i]>0) {
            mem[now][i]--;
            mem[i][now]--;
            rec(i, deep + 1);
            if(ok == 1) return;
            mem[now][i]++;
            mem[i][now]++;
        }
    }
}

int main(void) {
    while(scanf("%d", &n) && n != 0) {
        memset(mem, 0, sizeof(mem));
        ok = 0;
        for(i = 0; i < n; i++) {
            scanf("%d%d", &a, &b);
            mem[a][b] += 1;
            mem[b][a] += 1;
        }
        for(k = 0; k <= 6; k++) {
            rec(k, 0);
            if(ok == 1) break;
        }
	// ok == 1, matching perfeito
    }
}
//*******************************************************
//Domino perfect matching - graph
void dfs(int x) {
    vis[x] = 1;
    for(int j = 0; j <= 6; j++) {
        if(vis[j] == 0 && mem[x][j] == 1) dfs(j);
    }
}

int main(void) {
    while(scanf("%d", &n) && n != 0) {
        memset(mem, 0, sizeof(mem)); memset(vis, 0, sizeof(vis)); memset(ct, 0, sizeof(ct));
        for(int i = 0; i < n; i++) {
            scanf("%d%d", &a, &b);
            ct[a] += 1;
            ct[b] += 1;
            mem[a][b] = 1;
            mem[b][a] = 1;
        }
        for(int i = 0; i <= 6; i++) {
            if(ct[i] > 0) {
                dfs(i); break;
            }
        }
        ok = 1;
        for(int i = 0; i <= 6; i++) {
            if(ct[i] > 0 && !vis[i]) {
                ok = 0;
            }
        }
        int o = 0;
        for(int i = 0; i <= 6; i++) {
            if(ct[i] % 2 == 1) o++;
        }
        printf("Teste %d\n%s\n\n", teste++, ok == 1 && (o == 0 || o == 2) ? "sim" : "nao");
    }
}
/* *************************** Data Structures ***************************/
//******************************************************
//Order statistics tree inside STL
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
using namespace std;
template <typename T>
using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

int main(){
	ordered_set<int>  s;
	s.insert(1); 
	s.insert(3);
	cout << s.order_of_key(2) << endl; // the number of elements in the s less than 2
	cout << *s.find_by_order(0) << endl; // print the 0-th smallest number in s(0-based)
}
//******************************************************
//Splay Tree
template< typename T, typename Comp = std::less< T > >
class splay_tree {
private:
  Comp comp;
  unsigned long p_size;
 
  struct node {
    node *left, *right;
    node *parent;
    T key;
    node( const T& init = T( ) ) : left( 0 ), right( 0 ), parent( 0 ), key( init ) { }
  } *root;
 
  void left_rotate( node *x ) {
    node *y = x->right;
    x->right = y->left;
    if( y->left ) y->left->parent = x;
    y->parent = x->parent;
    if( !x->parent ) root = y;
    else if( x == x->parent->left ) x->parent->left = y;
    else x->parent->right = y;
    y->left = x;
    x->parent = y;
  }
 
  void right_rotate( node *x ) {
    node *y = x->left;
    x->left = y->right;
    if( y->right ) y->right->parent = x;
    y->parent = x->parent;
    if( !x->parent ) root = y;
    else if( x == x->parent->left ) x->parent->left = y;
    else x->parent->right = y;
    y->right = x;
    x->parent = y;
  }
 
  void splay( node *x ) {
    while( x->parent ) {
      if( !x->parent->parent ) {
        if( x->parent->left == x ) right_rotate( x->parent );
        else left_rotate( x->parent );
      } else if( x->parent->left == x && x->parent->parent->left == x->parent ) {
        right_rotate( x->parent->parent );
        right_rotate( x->parent );
      } else if( x->parent->right == x && x->parent->parent->right == x->parent ) {
        left_rotate( x->parent->parent );
        left_rotate( x->parent );
      } else if( x->parent->left == x && x->parent->parent->right == x->parent ) {
        right_rotate( x->parent );
        left_rotate( x->parent );
      } else {
        left_rotate( x->parent );
        right_rotate( x->parent );
      }
    }
  }
 
  void replace( node *u, node *v ) {
    if( !u->parent ) root = v;
    else if( u == u->parent->left ) u->parent->left = v;
    else u->parent->right = v;
    if( v ) v->parent = u->parent;
  }
 
  node* subtree_minimum( node *u ) {
    while( u->left ) u = u->left;
    return u;
  }
 
  node* subtree_maximum( node *u ) {
    while( u->right ) u = u->right;
    return u;
  }
public:
  splay_tree( ) : root( 0 ), p_size( 0 ) { }
 
  void insert( const T &key ) {
    node *z = root;
    node *p = 0;
 
    while( z ) {
      p = z;
      if( comp( z->key, key ) ) z = z->right;
      else z = z->left;
    }
 
    z = new node( key );
    z->parent = p;
 
    if( !p ) root = z;
    else if( comp( p->key, z->key ) ) p->right = z;
    else p->left = z;
 
    splay( z );
    p_size++;
  }
 
  node* find( const T &key ) {
    node *z = root;
    while( z ) {
      if( comp( z->key, key ) ) z = z->right;
      else if( comp( key, z->key ) ) z = z->left;
      else return z;
    }
    return 0;
  }
 
  void erase( const T &key ) {
    node *z = find( key );
    if( !z ) return;
 
    splay( z );
 
    if( !z->left ) replace( z, z->right );
    else if( !z->right ) replace( z, z->left );
    else {
      node *y = subtree_minimum( z->right );
      if( y->parent != z ) {
        replace( y, y->right );
        y->right = z->right;
        y->right->parent = y;
      }
      replace( z, y );
      y->left = z->left;
      y->left->parent = y;
    }
 
    delete z;
    p_size--;
  }
 
  const T& minimum( ) { return subtree_minimum( root )->key; }
  const T& maximum( ) { return subtree_maximum( root )->key; }
 
  bool empty( ) const { return root == 0; }
  unsigned long size( ) const { return p_size; }
};
//*******************************************************
//Trie
struct Trie {
    Trie *child[MAXN];
    int prefixes;
    int words;

    Trie() {
        int i;
        prefixes = words = 0;
        for(i = 0; i < MAXN; i++) {
            child[i] = NULL;
        }
    }

    void addWord(string s, int pos = 0) {
        if(pos == s.size()) {
            words++;
            return;
        }

        int letter_pos = s[pos] - 'a';

        Trie *t = child[letter_pos];

        if(child[letter_pos] == NULL) {
            t = child[letter_pos] = new Trie();
            t->prefixes = 1;
        } else {
            t->prefixes = t->prefixes + 1;
        }
        t->addWord(s, pos + 1);
    }

    int count(string s, int pos = 0, int k = 0) {
        if(pos == s.size()) return k;
        Trie *t = child[s[pos] - 'a'];
        if(t == NULL) return 0;
        return t->count(s, pos + 1, (prefixes == t->prefixes) ? k: k + 1);
    }
};
//*******************************************************
//Union Find
struct UnionFind {
    int N, *id, *sz;

    UnionFind(int _N) {
        id = new int[_N];
        sz = new int[_N];
        for(int i = 0; i < _N; i++) {
            id[i] = i;
            sz[i] = 1;
        }
        N = _N;
    }
    int root(int i) {
        while(i != id[i]) {
            id[i] = id[id[i]];
            i = id[i];
        }
        return i;
    }
    bool find(int p, int q) {
        return root(p) == root(q);
    }
    void unite(int p, int q) {
        int i = root(p);
        int j = root(q);
        if(i == j) return;
        if(sz[i] < sz[j]) {
            id[i] = j; sz[j] += sz[i];
        } else {
            id[j] = i; sz[i] += sz[j];
        }
    }
};
//*******************************************************
//Binary Indexed Tree(Fenwick Tree)
template<typename T = int>
struct FenwickTree {
    int N;
    T *values;

    FenwickTree(int N) {
        this->N = N;
        values = new T[N+5];

        for(int i = 1; i <= N; i++) values[i] = 0;
    }

    void increase(int index, T add) {
        while(index <= N) {
            values[index] += add;
            index += (index & -index);
        }
    }

    void update(int index, T new_value) {
        increase(index, new_value - readSingle(index));
    }

    T read(int index) {
        T sum = 0;

        while(index > 0) {
            sum += values[index];
            index -= (index & -index);
        }

        return sum;
    }

    T readSingle(int index){
        T sum = values[index];
        if(index > 0) {
            int z = index - (index & -index);
            index--;
            while(index != z) {
                sum -= values[index];
                index -= (index & -index);
            }
        }
        return sum;
    }

    T read(int low, int high) {
        return read(high) - read(low - 1);
    }

    void scale(T factor) {
        for(int i = 1; i <= N; i++) {
            values[i] /= factor;
        }
    }

    void power(T factor) {
        for(int i = 1; i <= N; i++) {
            values[i] *= factor;
        }
    }
};
//*******************************************************
//Binary Indexed Tree 2D(Fenwick Tree 2D)
const int INF = 1000 * 1000 * 1000;

int n, m;
vector <vector <int>> t;

void init(int _n, int _m) {
    n = _n;
    m = _m;
    for(int i = 0; i < n; i++) {
        t.push_back(vector<int>(m, 0));
    }
}

int sum(int x, int y) {
    int result = 0;
    for (int i = x; i> = 0; i = (i & (i +1)) - 1) {
        for (int j = y; j> = 0; j = (j & (j +1)) - 1) {
            result += t[i][j];
        }
    }
    return result;
}

void inc (int x, int y, int delta) {
    for (int i = x; i <n; i = (i | (i +1))) {
        for (int j = y; j <m; j = (j | (j +1))) {
            t[i][j] += delta;
        }
    }
}

void update(int x, int y, int new_value) {
    for (int i = x; i> = 0; i = (i & (i +1)) - 1) {
        for (int j = y; j> = 0; j = (j & (j +1)) - 1) {
            t[i][j] = new_value;
        }
    }
}

// sum[(r1, c1), (r2, c2)]
int sum(int[][] t, int r1, int c1, int r2, int c2) {
	return sum(t, r2, c2) - sum(t, r1 - 1, c2) - sum(t, r2, c1 - 1) + sum(t, r1 - 1, c1 - 1);
}
//*******************************************************
//Sparse Table for RMQ
int sparse_min[22][MAXN];
int pw[MAXN];

void build_sparse() {
	pw[1] = 0;
	
	for (int i = 0; i < N; i++) {
		sparse_min[0][i] = P[i];

		if (i > 1) {
			pw[i] = pw[i - 1] + ((i & (-i)) == i);
		}
	}
	
	for (int i = 1; (1<<i) <= N; i++) {
		for (int j = 0; j + (1 << i) <= N; j++) {			
			sparse_min[i][j] = min(sparse_min[i - 1][j], sparse_min[i - 1][j + (1 << (i - 1))]);
		}
	} 
}

bool query(int l, int r) {
	int lg = pw[r - l];

	int s_min = min(sparse_min[lg][l], sparse_min[lg][r - (1 << lg) + 1]);

	return s_min;
}

//*******************************************************
//Segment Tree with Lazy Propagation
void goDown(int node, int l, int r) {    
    if (lazy[node]) {
        tree[node] += lazy[node];
        
        if (l != r) {
            lazy[2 * node] += lazy[node];
            lazy[2 * node + 1] += lazy[node];
        } 
    }
    lazy[node] = 0;
}

void build(int node, int l, int r) {
    if (l == r) {
        tree[node] = A[l];
    } else {
        int m = (l + r) / 2;
        
        build(2 * node, l, m);
        build(2 * node + 1, m + 1, r);
        
        tree[node] = max(tree[2 * node], tree[2 * node + 1]);
    }
}

Int query(int node, int l, int r, int bl, int br) {
    goDown(node, l, r);
    if (l >= bl && r <= br) {
        return tree[node];
    } else if (l > br || r < bl) { 
        return -INF;
    } else {
        int m = (l + r) / 2;
        
        Int a = query(2 * node, l, m, bl, br);
        Int b = query(2 * node + 1, m + 1, r, bl, br);
        
        return max(a, b);
    }
}

void update(int node, int l, int r, int bl, int br, Int value) {    
    goDown(node, l, r);
    if (l > r) {
        return;
    } else if (l > br || r < bl) {
        return;
    } else if (l >= bl && r <= br) {
        lazy[node] = value;    
        goDown(node, l, r);
    } else {
        int m = (l + r) / 2;       
        
        update(2 * node, l, m, bl, br, value);
        update(2 * node + 1, m + 1, r, bl, br, value);
        
        tree[node] = max(tree[2 * node], tree[2 * node + 1]);
    }    
}
//*******************************************************
//Simple Segment Tree
struct SegmentTree {
	int N;
	int tree[MAXN];
	int lazy[MAXN];

	SegmentTree(int N, int base[MAXN]): N(N) {
		build(1, 0, N - 1, base);
	}	

	void build(int node, int l, int r, int base[MAXN]) {
		if (l == r) {
			tree[node] = base[l];
		} else {
			int m = (l + r) / 2;

			build(2 * node, l, m, base);
			build(2 * node + 1, m + 1, r, base);

			tree[node] = min(tree[2 * node], tree[2 * node + 1]);
		}
	}

	int query(int node, int l, int r, int bl, int br) {
		if (l > r || l > br || r < bl) {
			return INT_MAX;
		} else if (l >= bl && r <= br) {
			return tree[node];
		} else {
			int m = (l + r) / 2;
			
			int a = query(2 * node, l, m, bl, br);
			int b = query(2 * node + 1, m + 1, r, bl, br);

			return min(a, b);
		}
	}
};
//*******************************************************
// Segment Tree 2D


pair<int, int> tree[4 * MAXN][4 * MAXN];

void build_y(int nx, int ny, int xl, int xr, int yl, int yr) {
	if (yl == yr) {
		if (xl == xr) {
			tree[nx][ny].first = tree[nx][ny].second = P[xl][yl];
		} else {
			tree[nx][ny].first = min(tree[2 * nx][ny].first, tree[2 * nx + 1][ny].first);
			tree[nx][ny].second = max(tree[2 * nx][ny].second, tree[2 * nx + 1][ny].second);
		}
	} else {
		int m = (yl + yr) / 2;

		build_y(nx, 2 * ny, xl, xr, yl, m);
		build_y(nx, 2 * ny + 1, xl, xr, m + 1, yr);
		
		tree[nx][ny].first = min(tree[nx][2 * ny].first, tree[nx][2 * ny + 1].first);
		tree[nx][ny].second = max(tree[nx][2 * ny].second, tree[nx][2 * ny + 1].second);
	}
}

void build_x(int nx, int xl, int xr) {
	if (xl > xr) {
		return;
	} else if (xl != xr) {
		int m = (xl + xr) / 2;
		
		build_x(2 * nx, xl, m);
		build_x(2 * nx + 1, m + 1, xr);
	}
	build_y(nx, 1, xl, xr, 0, M - 1);
}

pair<int, int> query_y(int nx, int ny, int xl, int xr, int yl, int yr, int bound_lx, int bound_rx, int bound_ly, int bound_ry) {
	if (yl > yr || yl > bound_ry || yr < bound_ly) {
		return make_pair(INF, -INF);
	} else if (yl >= bound_ly && yr <= bound_ry) {
		return tree[nx][ny];
	} else {
		int m = (yl + yr) / 2;

		pair<int, int> q1 = query_y(nx, 2 * ny, xl, xr, yl, m, bound_lx, bound_rx, bound_ly, bound_ry);
		pair<int, int> q2 = query_y(nx, 2 * ny + 1, xl, xr, m + 1, yr, bound_lx, bound_rx, bound_ly, bound_ry);

		return make_pair(min(q1.first, q2.first), max(q1.second, q2.second));
	}
}

pair<int, int> query_x(int nx, int ny, int xl, int xr, int yl, int yr, int bound_lx, int bound_rx, int bound_ly, int bound_ry) {
	if (xl > xr || xl > bound_rx || xr < bound_lx) {
		return make_pair(INF, -INF);
	} else if (xl >= bound_lx && xr <= bound_rx) {
		return query_y(nx, 1, xl, xr, 0, M - 1, bound_lx, bound_rx, bound_ly, bound_ry);
	} else {
		int m = (xl + xr) / 2;
		
		pair<int, int> q1 = query_x(2 * nx, ny, xl, m, yl, yr, bound_lx, bound_rx, bound_ly, bound_ry);
		pair<int, int> q2 = query_x(2 * nx + 1, ny, m + 1, xr, yl, yr, bound_lx, bound_rx, bound_ly, bound_ry);

		return make_pair(min(q1.first, q2.first), max(q1.second, q2.second));
	}
}

pair<int, int> query(int nx, int ny, int xl, int xr, int yl, int yr, int bound_lx, int bound_rx, int bound_ly, int bound_ry) {
	return query_x(1, 1, xl, xr, yl, yr, bound_lx, bound_rx, bound_ly, bound_ry);
}

void update_y(int nx, int ny, int xl, int xr, int yl, int yr, int posx, int posy, int value) {
	if (yl == yr) {
		if (xl == xr) {
			tree[nx][ny].first = tree[nx][ny].second = value;
		} else {
			tree[nx][ny].first = min(tree[2 * nx][ny].first, tree[2 * nx + 1][ny].first);
			tree[nx][ny].second = max(tree[2 * nx][ny].second, tree[2 * nx + 1][ny].second);
		}
	} else {
		int m = (yl + yr) / 2;
		
		if (posy <= m) {
			update_y(nx, 2 * ny, xl, xr, yl, m, posx, posy, value);
		} else {
			update_y(nx, 2 * ny + 1, xl, xr, m + 1, yr, posx, posy, value);
		}

		tree[nx][ny].first = min(tree[nx][2 * ny].first, tree[nx][2 * ny + 1].first);
		tree[nx][ny].second = max(tree[nx][2 * ny].second, tree[nx][2 * ny + 1].second);
	}
}

void update_x(int nx, int ny, int xl, int xr, int yl, int yr, int posx, int posy, int value) {	
	if (xl != xr) {
		int m = (xl + xr) / 2;

		if (posx <= m) {
			update_x(2 * nx, ny, xl, m, yl, yr, posx, posy, value);
		} else {
			update_x(2 * nx + 1, ny, m + 1, xr, yl, yr, posx, posy, value);
		}
	}
	update_y(nx, 1, xl, xr, 0, M - 1, posx, posy, value);
}

void update(int nx, int ny, int xl, int xr, int yl, int yr, int posx, int posy, int value) {
	return update_x(1, 1, xl, xr, yl, yr, posx, posy, value);
}

/*********************************************************************/
//Sliding RMQ in O(N)
void maxSlidingWindow(int A[], int n, int w, int B[]) {
  deque<int> Q;
  for (int i = 0; i < w; i++) {
    while (!Q.empty() && A[i] >= A[Q.back()])
      Q.pop_back();
    Q.push_back(i);
  }
  for (int i = w; i < n; i++) {
    B[i-w] = A[Q.front()];
    while (!Q.empty() && A[i] >= A[Q.back()])
      Q.pop_back();
    while (!Q.empty() && Q.front() <= i-w)
      Q.pop_front();
    Q.push_back(i);
  }
  B[n-w] = A[Q.front()];
}
/*********************************************************************/
//Sliding RMQ in O(N) - Faster (No use of STL)
int Q[MAXN];

Int maxSlidingWindow(Int A[], int n, int w, Int B[]) {
	int b = 0, e = 0;
	Int ans = 0LL;
	for (int i = 0; i < w; i++) {
		while (!(b == e) && A[i] >= A[Q[e-1]]) {
			e -= 1;
		}
		Q[e++] = i;
	}
	for (int i = w; i < n; i++) {
		B[i-w] = A[Q[b]];
		ans += B[i-w];
		while (!(e == b) && A[i] >= A[Q[e-1]])
			e--;
		while (!(e == b) && Q[b] <= i-w)
			b += 1;
		Q[e++] = i;
	}
	ans += A[Q[b]];

	return ans;
}
/**************************** NUMBER THEORY ***************************/
//******************************************************
//Counting number of ones in numbers from 1 to N
Int func(Int x) {
    Int ans = 0LL;
    Int bits = 1LL;
    Int range = 2LL;
 
    int i;
    Int len = (Int) floor(log10(x) / log10(2)) + 1;
 
    for (i = 0; i < len; i++) {
        if (x >= range) {
            if (x % range == 0) {
                ans += (Int) (x / range) * bits;
            } else {
                Int md = x % range + 1;
                Int div = floor(x / range);
 
                ans += div * bits + max(0LL, md - range / 2LL);
            }
        } else {
                Int c_range = range - (range - x) + 1;
                ans += max(0LL, c_range - range / 2LL);
        }
 
        bits *= 2LL;
        range *= 2LL;
    }
 
    return ans;
}
//******************************************************
//Return the N-th palindromic number
 
std::string number_palindrome(int N) {
    if(N < 10){
        return std::string(1, char('0' + N));
    }
    long long sum = 0, digits = 1, v;
    for(; ; digits++){
        if(digits % 2 == 0){
            v = std::pow(10, digits/2-1) * 9;
        }else{
            v = std::pow(10, (digits+1)/2-1) * 9;
        }
        if(v + sum >= N) break;
        sum += v;
    }
    //I have to find the M-th palindromic number with X digits:
    long long Mth = N-sum;
    long long sz = (digits+1) / 2;
    long long pattern = std::pow(10, sz-1);
    pattern += (Mth-1);
    std::vector<int> tmp;
    while(pattern > 0){
        tmp.insert(tmp.begin(), pattern % 10);
        pattern /= 10;
    }
    int idx = digits-tmp.size() - 1;
    std::string ans = "";
    for(int i = 0; i < tmp.size(); i++){
        ans += std::string(1, char('0' + tmp[i]));
    }
    for(;idx >= 0;){
        ans += std::string(1, char('0' + tmp[idx--]));
    }
    return ans;
}
//******************************************************
//Generate Highly Composite Numbers
// for each HCN i, no number less than or equal i has more divisors than i.
bool p[MAXN];
vector<int> primes;

void build(void) {
	memset(p, true, sizeof(p));

	for (int i = 2; i <= MAXN; i++) {
		if (p[i]) {
			primes.push_back(i);
			for (int j = i * i; j <= MAXN; j += i) {
				p[j] = false;
			}
		}
	}
}

int func(Int x) {
	int ans = 1;

	for (int i = 0; i < (int) primes.size() && x > 1; i++) {
		if (x % primes[i] == 0) {
			int curr = 0;
			while (x % primes[i] == 0) {
				x /= primes[i];
				curr += 1;
			}
			ans *= (curr + 1);
		}
	}
	return ans;
}

set<Int> st;

void go(int id, Int v, int last) {
	Int base = primes[id];
	if (v > MAXV) return;
	st.insert(v);

	for (int i = 0; i <= last; i++) {
		v *= (Int) base;
		if (v > MAXV) break;
		go(id + 1, v, i);
	}
}
vector<Int> ans;

for (set<Int>::iterator it = st.begin(); it != st.end(); it++) {
	int s = func(*it);
		if (s > curr) {
		ans.push_back(*it);
		curr = s;
	}
}
//******************************************************
//Inverse mod using extended little fermat theorem
/* This function calculates (a^b)%MOD */
int pow(int a, int b, int MOD) {
int x = 1, y = a;
    while(b > 0) {
        if(b%2 == 1) {
            x=(x*y);
            if(x>MOD) x%=MOD;
        }
        y = (y*y);
        if(y>MOD) y%=MOD;
        b /= 2;
    }
    return x;
}
 
int modInverse(int a, int m) {
    return pow(a,m-2,m);
}
//******************************************************
//Inverse mod using extended euclid algorith,

/* This function return the gcd of a and b followed by
    the pair x and y of equation ax + by = gcd(a,b)*/
pair<int, pair<int, int> > extendedEuclid(int a, int b) {
    int x = 1, y = 0;
    int xLast = 0, yLast = 1;
    int q, r, m, n;
    while(a != 0) {
        q = b / a;
        r = b % a;
        m = xLast - q * x;
        n = yLast - q * y;
        xLast = x, yLast = y;
        x = m, y = n;
        b = a, a = r;
    }
    return make_pair(b, make_pair(xLast, yLast));
}
 
int modInverse(int a, int m) {
    return (extendedEuclid(a,m).second.first + m) % m;
}
/*********************************************************************/
//Contando a soma de todos os numeros do intervalo sum(a, b)		   
public static int sum(int a, int b) {
	a -= 1;
	return ((b * (b + 1)) / 2) - (((a) * (a + 1)) / 2);
}
//*******************************************************
//modpow(a, n, mod) - calcula a^n % mod de maneira eficiente
int modpow(int a, int n, int mod) {
	int res(1);
        while (n) {
                if (n&1)
                        res=(res*a)%mod;
                a=(a*1ll*a)%mod;
                n>>=1;
        }
        return res;
}
//*******************************************************
//Calculando n-th numero de fibonnaci em O(n) (Deve ser Evitado)
static double inverseSqrt5 = 1 / sqrt(5);
static double phi = (1 + sqrt(5)) / 2;

ll func(ll n) {
    return (ll) floor(pow(phi, n) * inverseSqrt5 + 0.5);
}
//*******************************************************
//Exponenciação rápida O(log(n))
int binpow (int a, int n) {
	int res = 1;
	while (n) {
		if (n & 1)
			res *= a;
		a *= a;
		n >>= 1;
	}
	return res;
}
//*******************************************************
// Fibonacci with fast doubling (faster than matrix exponentiation)
typedef long long int lli;
typedef pair<lli, lli> ii;

ii fast_doubling(lli n, lli mod) {
	if(n == 1) return ii(1, 1);
	else if(n == 2) return ii(1, 2);
	
	ii aux = fast_doubling(n/2, mod);
	ii ret;
	ret.first = (aux.first*(aux.second*2 + mod - aux.first))%mod;
	ret.second = ((lli)pow(aux.first, 2)+(lli)pow(aux.second, 2))%mod;
	
	if(n%2 == 0) {
		return ret;
	} else {
		return ii(ret.second, (ret.first+ret.second)%mod);
	}
}
//*******************************************************
//Contando o numero de divisores inteiros de um determinado nume 'N' O(sqrt(N))
int ct(int n) {
    if(n == 1) return 1L;

    int x = (int) sqrt(n);
    int counter = 0;

    for(int i = 1; i <= x; i++) {
        if(n % i == 0) {
            counter += 2;
        }
    }
    if(x * x == n) counter -= 1;
    return counter;
}
//*******************************************************
//Todos os divisores de 2 numeros, interseccao entre ambos
void gen(vector<int>& ans, vector<pair<int, int> >& v, int id, int x, int N) {
    if (id == N) {
        ans.push_back(x);
    } else {
        for (int i = 0; i <= v[id].second; i++) {
            gen(ans, v, id + 1, x, N);
            x *= v[id].first;
        }
    }
}

vector<int> func(int x) {
    vector<pair<int, int> > vp;

    int d = 1;

    for (int i = 2; i * i <= x; i += d, d = 2) {
        if (x % i == 0) {
            vp.push_back(make_pair(i, 0));

            for ( ; x % i == 0; ) {
                vp.back().second += 1;
                x /= i;
            }
        }
    }
    if (x != 1) {
        vp.push_back(make_pair(x, 1));
    }

    vector<int> ans;

    gen(ans, vp, 0, 1, (int) vp.size());

    return ans;
}

vector<int> d1 = func(A);
vector<int> d2 = func(B);

sort(d1.begin(), d1.end());
sort(d2.begin(), d2.end());

set_intersection(d1.begin(), d1.end(), d2.begin(), d2.end(), inserter(dv, dv.begin()));
//*******************************************************
//Checando se um numero é primo ou não
bool isPrime(long long n) {
    if(n <= 1) return false;
    if(n == 2) return true;
    if(n % 2 == 0) return false;

    long long m = (long long) sqrt(n);

    for(i = 3L; i <= m; i += 2L) {
        if(n % i == 0) {
            return false;
        }
    }
    return true;
}
//*******************************************************
//Crivo de Erastotenes Eficiente
const int N = 10000000;
int lp[N+1];
vector<int> pr;

for(int i = 2; i <= N; ++i) {
	if(lp[i] == 0) {
		lp[i] = i;
        pr.push_back(i);
    }
    for(int j = 0; j < (int) pr.size() && pr[j] <= lp[i] && i * pr[j] <= N; ++j) {
		lp[i * pr[j]] = pr[j];
    }
}
//*******************************************************
//Crivo de Erastotenes Comum - (Todos os numeros primes <= N)
bool sieve(int n) {
	bool prime[n+1];
	fill(prime, prime + n + 1,true);
	prime[0] = false;
	prime[1] = false;

	int m = (int) sqrt(n);

	for(int i = 2; i <= m; i++) {
		if(prime[i]) {
			for (int k=i*i; k<=n; k+=i) {
				prime[k]=false;
			}
		}
	}
	return prime;
}
//*******************************************************
//Problema de Josephus (ultimo a ser removido do circulo, removendo de D em D)
int N, D;

int func(void) {
    int r = 0, i = 2;

    while (i <= N) {
        r = (r + D) % i;
        i += 1;
    }

    return r + 1;
}
//*******************************************************
//Little Fermat Primarity test - (Testar se um numero e primo de maneira eficiente
BigInteger getRandomFermatBase(BigInteger n) {
	while(true) {
		final BigInteger a = new BigInteger (n.bitLength(), rand);
		if (BigInteger.ONE.compareTo(a) <= 0 && a.compareTo(n) < 0) {
			return a;
		}
	}
}

public static boolean checkPrime(BigInteger n, int maxIterations) {
	if(n.equals(BigInteger.ONE)) {
		return false;
	}
	for (int i = 0; i < maxIterations; i++) {
		BigInteger a = getRandomFermatBase(n);
		a = a.modPow(n.subtract(BigInteger.ONE), n);
		
		if (!a.equals(BigInteger.ONE)) {
			return false;
		}
	}
	return true;
}
//*******************************************************
//Soma de todos os divisores de um numero
vector<int> primes;

void build(void) {
    vector<int> memo(N+5, 1); memo[0] = memo[1] = 0;

    for(int i = 2; i <= (int) sqrt(N); i++) if(memo[i] == 1) {
        for(int j = i * i; j <= N; j += i) {
            memo[j] = 0;
        }
    }

    for(int i = 2; i <= N; i++) if(memo[i]) primes.push_back(i);
}

void mount(int x) {
    vector<int> fact;
    int base = 0, other = x, mult = 1;
    while(x > 1) {
        int cnt = 0;
        while(base < primes.size() && x % primes[base] == 0) {
            x /= primes[base];
            cnt += 1;
        }
        if(cnt) {
            mult *= (((int) pow(primes[base], cnt + 1) - 1) / (int) (primes[base] - 1));
        }
        base += 1;
    }
    sum[other] = mult - other;
}

//*******************************************************
//GCD - Maximo Divisor Comum
int gcd(int a, int b) {
	if(b == 0) return a;
	return gcd(b, a % b);
}
//*******************************************************
//LCM - Minimo Multiplo Comum
int lcm(int a, int b) {
	return a * b / gcd(a, b);
}
//*******************************************************
//Euler Phi Function (Get coprime numbers)
//*******************************************************
#include <iostream>
#include <limits.h>
#include <cstdlib>
#include <cmath>
using namespace std;

const int N1 = 50001, N2 = 5133;
bool isPrime[N1];
int prime[N2], nPrime, totient[N1];

void sieveAndTotient() {
    // reset
    for (int i = 0; i < N1; ++i)
        totient[i] = i;
    isPrime[0] = isPrime[1] = false;
    for (int i = 3; i < N1; i += 2)
        isPrime[i] = true;
    for (int i = 4; i < N1; i += 2)
        isPrime[i] = false;
    nPrime = 0;
    // 2
    // update for 2
    prime[nPrime++] = 2;
    for (int j = 2; j < N1; j += 2) {
        isPrime[j] = false;
        // totient for 2
        totient[j] -= totient[j] / 2;
    }
    isPrime[2] = true;
    // odds
    for (int i = 3; i < N1; i += 2)
        if (isPrime[i]) {
            // update for i
            prime[nPrime++] = i;
            if (i < INT_MAX)
                for (int j = i; j < N1; j += i) {
                    isPrime[j] = false;
                    // totient for i
                    totient[j] -= totient[j] / i;
                }
            isPrime[i] = true;
        }
}

int main() {
    sieveAndTotient();
    int in;
    while (cin >> in)
        cout << totient[in] << endl;
    return 0;
}
//*******************************************************
// Count number of digits used from 1 to N
//*******************************************************
Int func(int val) {
	int digitCount = (int) log10(val) + 1;
	Int ans = 0LL;
	Int p = 1LL;

	for (int i = 0; i < digitCount - 1; i++) {
		ans += p * 9 * (i + 1);
		p *= 10;
	}
	
	ans += (val - p + 1) * digitCount;
	
	return ans;
}
//*******************************************************
//Euler Phi Function (Get coprime numbers) - Faster
//*******************************************************
int fi(int n) {
	int result = n;
	for (int i = 2; i * i <= n; i++) {
		if (n % i == 0) {
			result -= result / i;
		}
		while (n % i == 0) {
			n /= i;
		}
	}
	if (n > 1) {
		result -= result / n;
	}
	return result;
}

//*******************************************************
//Fast method to get factorial of N MOD P, in O(N log(P))
//*******************************************************
int factmod (int n, int p) {
	int res = 1;
	while (n > 1) {
		res = (res * ((n/p) % 2 ? p-1 : 1)) % p;
		for (int i=2; i<=n%p; ++i)
			res = (res * i) % p;
		n /= p;
	}
	return res % p;
}
//*******************************************************
//Catalan numbers with DP
void getCatalan(int n){
    int catalan[n+1];
    int MOD = 100000000;
    for (int i=0; i <= n; i++){
        if (i==0 || i==1){
            catalan[i] = 1;
        }else{
            int sum =0;
            int l, r;
            for (int k=1;k<=i;k++){
                l = catalan[k-1] % MOD;
                r = catalan[i-k] % MOD;
                sum = (sum + (l * r) % MOD) % MOD;
            }
            catalan[i] = sum;
        }
    }
}
//Preprocessing Fatorial numbers and Answer in O(1)
Int catalan(int N) {
	Int ans = fat[2 * N];
	Int p = ((fat[N] * fat[N + 1]) % MOD) % MOD;
	ans *= modpow(p, MOD - 2, MOD);
	
	ans = ((ans % MOD) + MOD) % MOD;
	
	return ans;
}
//*******************************************************
//Euler phi function using less memory
//*******************************************************
#include <cstdio>
using namespace std;

typedef long long int64;

int64 totient(int64 n) {
    if (n == 1)
        return 1ll;
    int64 out = n;
    // 2
    if (n % 2 == 0) {
        out -= out / 2;
        do
            n /= 2;
        while (n % 2 == 0);
    }
    // odds
    for (int i = 3; i * i <= n; i += 2)
        if (n % i == 0) {
            out -= out / i;
            do
                n /= i;
            while (n % i == 0);
        }
    //
    if (n > 1)
        out -= out / n;
    return out;
}

int main() {
    int64 n;
    scanf("%lld", &n);
    printf("%lld\n", totient(n));
    return 0;
}
/* ***************************** BASE TRANSFORMATIONS ********************* */
//Chega se o digito corresponde a base numerica indicada
boolean isFromBase(char digit, int base) {
	if (digit >= 'A' && digit - 'A' + 10 >= base) {
		return false;
	} else if (digit < 'A' && digit - '0' >= base) {
		return false;
	} else {
		return true;
	}
}

//Qualuqer base para decimal
public int anyBaseToDec(String num, int fromBase) {
	int ans = 0;
	int n = num.length();
	for (int i = 0; i < num.length(); i++) {
		if (!isFromBase(num.charAt(i), fromBase)) return -1;
		if (num.charAt(i) >= 'A') {
			ans += (num.charAt(i) + 10 - 'A') * (modpow(fromBase, n - i - 1));
		} else {
			ans += (num.charAt(i) - '0') * (modpow(fromBase, n - i - 1));
		}
	}
	return ans;
}


//Decimal para outras bases
public String decToOthers(int value, int toBase) {
	if (value == 0) return "0";
	String ans = "";
	while (value > 0) {
		int aux = (value % toBase);
		if (aux > 9) {
			ans = (char) ('A' - 9 + aux - 1) + ans;
		} else {
			ans = (char) (aux + '0') + ans;
		}
		value /= toBase;
	}
	return ans;
}
//*******************************************************
//Commom Formulas
Tronco cônico:
Volume: (Pi * h / 3) * (r * r  +  r * R  +  R * R)
Área de superfície: Pi * (R + r) * sqrt(h^2 + (R-r)*(R-r))

Esfera:
Volume: 4/3 * pi * r *r *r
Área de superfície: 4 * pi * r *r
Area do fuso esférico: angle/360 * 4/3 * pi * r *r *r

Triangulos + Cirfunferencias:
Supondo que se tenha as medidas dos lados de um triangulo: a, b, c
P = semiperimetro = (a + b+ c)/2
M = mediana = sqrt((P*(P-a)*(P-b)*(P-c)));
Maior raio de um círculo inscrito numa circunferencia: M / P
Raio da circunferencia que passa pelos 3 vertices do triangulo: (a*b*c) / (4*M)

Equilateral Triangle
Area: L = lado = L*L * sqrt(3)/4
Altura: L * sqrt(3)/2

//*******************************************************
//Numeros de catalão: 
C n = n-ésimo número da sequencia
C-n = (2*n)! / (n+1)! * n! -> 1, 1, 2, 5, 14, 42, 132
